
# Chapter 6. Working with Sets

한 번에 한 행씩 데이터베이스의 데이터와 상호 작용할 수 있지만 관계형 데이터베이스는 실제로 집합에 관한 것입니다. 이 장에서는 다양한 집합 연산자를 사용하여 여러 결과 집합을 결합하는 방법을 살펴봅니다. 집합 이론에 대한 간략한 개요 후에 집합 연산자를 사용하여 여러 데이터 집합을 혼합하는 방법을 보여 드리겠습니다.

## 집합론 입문서

세계의 많은 지역에서 기본 집합 이론은 초등학교 수준의 수학 커리큘럼에 포함되어 있습니다. 아마도 그림 6-1과 같은 것을 본 것을 기억할 것입니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492057604/files/assets/lsq3_0601.png)

그림 6-1. 합집합

그림 6-1에서 음영 처리된 영역은 두 집합의 조합인 집합 A와 B의 합집합을 나타냅니다(겹치는 영역은 한 번만 포함됨). 이게 낯익기 시작했습니까? 그렇다면 마침내 그 지식을 사용할 기회를 얻게 될 것입니다. 그렇지 않은 경우 몇 가지 다이어그램을 사용하여 시각화하기 쉽기 때문에 걱정하지 마십시오.

원을 사용하여 두 데이터 세트(A 및 B)를 표현하고 두 세트에 공통인 데이터의 하위 집합을 상상해 보십시오. 이 공통 데이터는 그림 6-1에 표시된 중첩 영역으로 표시됩니다. 집합 이론은 데이터 집합 간의 중복 없이는 다소 흥미롭지 않기 때문에 동일한 다이어그램을 사용하여 각 집합 작업을 설명합니다. 두 데이터 세트 간의 겹침에만 관련된 또 다른 세트 작업이 있습니다. 이 작업을 교차라고 하며 그림 6-2에 설명되어 있습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492057604/files/assets/lsq3_0602.png)
Figure 6-2. 교차집합

The data set generated by the intersection of sets A and B is just the area of overlap between the two sets. If the two sets have no overlap, then the intersection operation yields the empty set.

The third and final set operation, which is demonstrated in Figure 6-3, is known as the except operation.

Figure 6-3 shows the results of A except B, which is the whole of set A minus any overlap with set B. If the two sets have no overlap, then the operation A except B yields the whole of set A.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492057604/files/assets/lsq3_0603.png)
Figure 6-3. 차집합

Using these three operations, or by combining different operations together, you can generate whatever results you need. For example, imagine that you want to build a set demonstrated by Figure 6-4.

![](![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492057604/files/assets/lsq3_0604.png))
Figure 6-4. Mystery data set

The data set you are looking for includes all of sets A and B without the overlapping region. You can’t achieve this outcome with just one of the three operations shown earlier; instead, you will need to first build a data set that encompasses all of sets A and B, and then utilize a second operation to remove the overlapping region. If the combined set is described as A union B, and the overlapping region is described as A intersect B, then the operation needed to generate the data set represented by Figure 6-4 would look as follows:
```
(A union B) except (A intersect B)
```
Of course, there are often multiple ways to achieve the same results; you could reach a similar outcome using the following operation:
```
(A except B) union (B except A)
```
While these concepts are fairly easy to understand using diagrams, the next sections show you how these concepts are applied to a relational database using the SQL set operators.


## Set Theory in Practice

데이터 세트를 나타내기 위해 이전 섹션의 다이어그램에서 사용된 원은 데이터 세트가 무엇을 구성하는지에 대해 아무 것도 전달하지 않습니다. 그러나 실제 데이터를 다룰 때 결합해야 하는 경우 관련된 데이터 세트의 구성을 설명할 필요가 있습니다. 예를 들어 정의가 다음과 같은 고객 테이블과 도시 테이블의 합집합을 생성하려고 하면 어떻게 되는지 상상해 보십시오.
```
mysql> desc customer;
+-------------+----------------------+------+-----+-------------------+
| Field       | Type                 | Null | Key | Default           |
+-------------+----------------------+------+-----+-------------------+
| customer_id | smallint(5) unsigned | NO   | PRI | NULL              |
| store_id    | tinyint(3) unsigned  | NO   | MUL | NULL              |
| first_name  | varchar(45)          | NO   |     | NULL              |
| last_name   | varchar(45)          | NO   | MUL | NULL              |
| email       | varchar(50)          | YES  |     | NULL              |
| address_id  | smallint(5) unsigned | NO   | MUL | NULL              |
| active      | tinyint(1)           | NO   |     | 1                 |
| create_date | datetime             | NO   |     | NULL              |
| last_update | timestamp            | YES  |     | CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+
```

```
mysql> desc city;
+-------------+----------------------+------+-----+-------------------+
| Field       | Type                 | Null | Key | Default           |
+-------------+----------------------+------+-----+-------------------+
| city_id     | smallint(5) unsigned | NO   | PRI | NULL              |
| city        | varchar(50)          | NO   |     | NULL              |
| country_id  | smallint(5) unsigned | NO   | MUL | NULL              |
| last_update | timestamp            | NO   |     | CURRENT_TIMESTAMP |
+-------------+----------------------+------+-----+-------------------+
```

결합된 경우 결과 집합의 첫 번째 열에는 customer.customer_id 및 city.city_id 열이 모두 포함되고 두 번째 열은 customer.store_id 및 city.city 열의 조합이 되는 식입니다. 일부 열 쌍(예: 두 개의 숫자 열)은 결합하기 쉽지만 문자열 열이 있는 숫자 열 또는 날짜 열이 있는 문자열 열과 같이 다른 열 쌍을 결합하는 방법이 명확하지 않습니다. 또한 도시 테이블에는 열이 4개뿐이므로 결합된 테이블의 다섯 번째에서 아홉 번째 열에는 고객 테이블의 다섯 번째에서 아홉 번째 열의 데이터만 포함됩니다. 분명히 결합하려는 두 데이터 세트 간에는 어느 정도 공통점이 있어야 합니다.

따라서 두 데이터 집합에 대해 집합 작업을 수행할 때 다음 지침을 적용해야 합니다.

- 두 데이터 세트의 열 수는 동일해야 합니다.

- 두 데이터 세트에서 각 열의 데이터 유형은 동일해야 합니다(또는 서버에서 하나를 다른 것으로 변환할 수 있어야 함).

이러한 규칙이 적용되면 실제로 "중첩 데이터"가 의미하는 바를 상상하기가 더 쉽습니다. 결합되는 두 세트의 각 열 쌍은 동일한 것으로 간주되는 두 테이블의 행에 대해 동일한 문자열, 숫자 또는 날짜를 포함해야 합니다.

다음과 같이 두 select 문 사이에 집합 연산자를 배치하여 집합 작업을 수행합니다.

```sql
mysql> SELECT 1 num, 'abc' str
    -> UNION
    -> SELECT 9 num, 'xyz' str;
```
```
+-----+-----+
| num | str |
+-----+-----+
|   1 | abc |
|   9 | xyz |
+-----+-----+
2 rows in set (0.02 sec)
```

각 개별 쿼리는 숫자 열과 문자열 열이 있는 단일 행으로 구성된 데이터 세트를 생성합니다. 이 경우 합집합인 집합 연산자는 데이터베이스 서버에 두 집합의 모든 행을 결합하도록 지시합니다. 따라서 최종 집합에는 두 열의 두 행이 포함됩니다. 이 쿼리는 여러 개의 독립적인 쿼리로 구성되어 있기 때문에 복합 쿼리라고 합니다. 나중에 보게 되겠지만, 최종 결과를 얻기 위해 여러 집합 작업이 필요한 경우 복합 쿼리에는 두 개 이상의 쿼리가 포함될 수 있습니다.


## Set 연산자

SQL 언어에는 이 장의 앞부분에서 설명한 다양한 집합 작업을 각각 수행할 수 있는 세 가지 집합 연산자가 포함되어 있습니다. 또한 각 집합 연산자에는 두 가지 특성이 있습니다. 하나는 중복을 포함하고 다른 하나는 중복을 제거합니다(그러나 반드시 모든 중복은 아님). 다음 하위 섹션에서는 각 연산자를 정의하고 사용 방법을 보여줍니다.

### union 연산자

Union 및 Union all 연산자를 사용하면 여러 데이터 세트를 결합할 수 있습니다. 둘의 차이점은 union은 결합된 집합을 정렬하고 중복을 제거하는 반면, union all은 그렇지 않다는 것입니다. 모두 통합을 사용하면 최종 데이터 세트의 행 수는 항상 결합되는 세트의 행 수 합계와 동일합니다. 이 작업은 서버가 중복 데이터를 확인할 필요가 없기 때문에 (서버 관점에서) 수행하기 가장 간단한 집합 작업입니다. 다음 예에서는 전체 통합 연산자를 사용하여 여러 테이블에서 성과 이름 집합을 생성하는 방법을 보여줍니다.

```sql
mysql> SELECT 'CUST' typ, c.first_name, c.last_name
    -> FROM customer c
    -> UNION ALL
    -> SELECT 'ACTR' typ, a.first_name, a.last_name
    -> FROM actor a;
```

```
+------+------------+-------------+
| typ  | first_name | last_name   |
+------+------------+-------------+
| CUST | MARY       | SMITH       |
| CUST | PATRICIA   | JOHNSON     |
| CUST | LINDA      | WILLIAMS    |
| CUST | BARBARA    | JONES       |
| CUST | ELIZABETH  | BROWN       |
| CUST | JENNIFER   | DAVIS       |
| CUST | MARIA      | MILLER      |
| CUST | SUSAN      | WILSON      |
| CUST | MARGARET   | MOORE       |
| CUST | DOROTHY    | TAYLOR      |
| CUST | LISA       | ANDERSON    |
| CUST | NANCY      | THOMAS      |
| CUST | KAREN      | JACKSON     |
...
| ACTR | BURT       | TEMPLE      |
| ACTR | MERYL      | ALLEN       |
| ACTR | JAYNE      | SILVERSTONE |
| ACTR | BELA       | WALKEN      |
| ACTR | REESE      | WEST        |
| ACTR | MARY       | KEITEL      |
| ACTR | JULIA      | FAWCETT     |
| ACTR | THORA      | TEMPLE      |
+------+------------+-------------+
799 rows in set (0.00 sec)
```

쿼리는 799개의 이름을 반환하며 599개의 행은 고객 테이블에서, 나머지 200개는 액터 테이블에서 가져옵니다. 별칭 유형이 있는 첫 번째 열은 필요하지 않지만 쿼리에서 반환된 각 이름의 소스를 표시하기 위해 추가되었습니다.

Union all 연산자가 중복을 제거하지 않는다는 점을 강조하기 위해 이전 예제의 또 다른 버전이지만 액터 테이블에 대해 두 개의 동일한 쿼리가 있습니다.

```sql
mysql> SELECT 'ACTR' typ, a.first_name, a.last_name
    -> FROM actor a
    -> UNION ALL
    -> SELECT 'ACTR' typ, a.first_name, a.last_name
    -> FROM actor a;
```
```
+------+-------------+--------------+
| typ  | first_name  | last_name    |
+------+-------------+--------------+
| ACTR | PENELOPE    | GUINESS      |
| ACTR | NICK        | WAHLBERG     |
| ACTR | ED          | CHASE        |
| ACTR | JENNIFER    | DAVIS        |
| ACTR | JOHNNY      | LOLLOBRIGIDA |
| ACTR | BETTE       | NICHOLSON    |
| ACTR | GRACE       | MOSTEL       |
...
| ACTR | BURT        | TEMPLE       |
| ACTR | MERYL       | ALLEN        |
| ACTR | JAYNE       | SILVERSTONE  |
| ACTR | BELA        | WALKEN       |
| ACTR | REESE       | WEST         |
| ACTR | MARY        | KEITEL       |
| ACTR | JULIA       | FAWCETT      |
| ACTR | THORA       | TEMPLE       |
+------+-------------+--------------+
400 rows in set (0.00 sec)
```

As you can see by the results, the 200 rows from the actor table are included twice, for a total of 400 rows.

While you are unlikely to repeat the same query twice in a compound query, here is another compound query that returns duplicate data:

```sql
mysql> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
    -> UNION ALL
    -> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%';
```
```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JENNIFER   | DAVIS     |
| JENNIFER   | DAVIS     |
| JUDY       | DEAN      |
| JODIE      | DEGENERES |
| JULIANNE   | DENCH     |
+------------+-----------+
5 rows in set (0.00 sec)
```

Both queries return the names of people having the initials JD. Of the five rows in the result set, one of them is a duplicate (Jennifer Davis). If you would like your combined table to exclude duplicate rows, you need to use the union operator instead of union all:

```sql
mysql> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
    -> UNION
    -> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%';
```
```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JENNIFER   | DAVIS     |
| JUDY       | DEAN      |
| JODIE      | DEGENERES |
| JULIANNE   | DENCH     |
+------------+-----------+
4 rows in set (0.00 sec)
```
For this version of the query, only the four distinct names are included in the result set, rather than the five rows returned when using union all.

### intersect Operator

ANSI SQL 사양에는 교차를 수행하기 위한 교차 연산자가 포함되어 있습니다. **불행히도 MySQL 버전 8.0은 교차 연산자를 구현하지 않습니다**. Oracle 또는 SQL Server 2008을 사용하는 경우 intersect를 사용할 수 있습니다. 그러나 이 책의 모든 예제에 MySQL을 사용하고 있기 때문에 이 섹션의 예제 쿼리에 대한 결과 집합은 조작된 것이며 버전 8.0 이하의 어떤 버전에서도 실행할 수 없습니다. 또한 MySQL 서버에서 명령문이 실행되지 않기 때문에 MySQL 프롬프트(mysql>)를 표시하지 않습니다.

복합 쿼리의 두 쿼리가 겹치지 않는 데이터 집합을 반환하는 경우 교차점은 빈 집합이 됩니다. 다음 쿼리를 고려하십시오.

```sql
SELECT c.first_name, c.last_name
FROM customer c
WHERE c.first_name LIKE 'D%' AND c.last_name LIKE 'T%'
INTERSECT
SELECT a.first_name, a.last_name
FROM actor a
WHERE a.first_name LIKE 'D%' AND a.last_name LIKE 'T%';
```
```
Empty set (0.04 sec)
```
While there are both actors and customers having the initials DT, these sets are completely nonoverlapping, so the intersection of the two sets yields the empty set. If we switch back to the initials JD, however, the intersection will yield a single row:

```sql
SELECT c.first_name, c.last_name
FROM customer c
WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
INTERSECT
SELECT a.first_name, a.last_name
FROM actor a
WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%';
```
```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JENNIFER   | DAVIS     |
+------------+-----------+
1 row in set (0.00 sec)
```
The intersection of these two queries yields Jennifer Davis, which is the only name found in both queries’ result sets.

Along with the intersect operator, which removes any duplicate rows found in the overlapping region, the ANSI SQL specification calls for an intersect all operator, which does not remove duplicates. The only database server that currently implements the intersect all operator is IBM’s DB2 Universal Server.

### except Operator

ANSI SQL 사양에는 예외 작업을 수행하기 위한 예외 연산자가 포함되어 있습니다. 다시 한 번, **불행히도 MySQL 버전 8.0은 except 연산자를 구현하지 않으므로** 이 섹션에도 이전 섹션과 동일한 규칙이 적용됩니다.

---
노트

Oracle 데이터베이스를 사용하는 경우 ANSI와 호환되지 않는 빼기 연산자를 대신 사용해야 합니다.

---

예외 연산자는 첫 번째 결과 집합에서 두 번째 결과 집합과 겹치는 부분을 뺀 값을 반환합니다. 다음은 이전 섹션의 예입니다. 그러나 교차 대신 예외를 사용하고 쿼리 순서를 반대로 합니다.

```sql
SELECT a.first_name, a.last_name
FROM actor a
WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
EXCEPT
SELECT c.first_name, c.last_name
FROM customer c
WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%';
```

```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JUDY       | DEAN      |
| JODIE      | DEGENERES |
| JULIANNE   | DENCH     |
+------------+-----------+
3 rows in set (0.00 sec)
```
이 버전의 쿼리에서 결과 집합은 두 쿼리의 결과 집합에서 찾은 Jennifer Davis를 뺀 첫 번째 쿼리의 세 행으로 구성됩니다. 또한 ANSI SQL 사양에 명시되어 있는 except all 연산자도 있지만, 다시 한 번 IBM의 DB2 Universal Server만이 except all 연산자를 구현했습니다.

모든 연산자를 제외하고는 약간 까다롭기 때문에 중복 데이터를 처리하는 방법을 보여주는 예가 있습니다. 다음과 같은 두 개의 데이터 세트가 있다고 가정해 보겠습니다.

```
Set A
+----------+
| actor_id |
+----------+
|       10 |
|       11 |
|       12 |
|       10 |
|       10 |
+----------+
Set B
+----------+
| actor_id |
+----------+
|       10 |
|       10 |
+----------+
```

The operation A except B yields the following:

```
+----------+
| actor_id |
+----------+
|       11 |
|       12 |
+----------+
```

If you change the operation to A except all B, you will see the following:
```
+----------+
| actor_id |
+----------+
|       10 |
|       11 |
|       12 |
+----------+
```
Therefore, the difference between the two operations is that except removes all occurrences of duplicate data from set A, whereas except all removes only one occurrence of duplicate data from set A for every occurrence in set B.



## Set Operation Rules

다음 섹션에서는 복합 쿼리로 작업할 때 따라야 하는 몇 가지 규칙을 간략하게 설명합니다.

### 복합 쿼리 결과 정렬

복합 쿼리의 결과를 정렬하려면 마지막 쿼리 뒤에 order by 절을 추가하면 됩니다. order by 절에서 열 이름을 지정할 때 복합 쿼리의 첫 번째 쿼리에서 열 이름을 선택해야 합니다. 종종 열 이름은 복합 쿼리의 두 쿼리에 대해 동일하지만 다음과 같이 반드시 그럴 필요는 없습니다.

```sql
mysql> SELECT a.first_name fname, a.last_name lname
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
    -> UNION ALL
    -> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
    -> ORDER BY lname, fname;
+----------+-----------+
| fname    | lname     |
+----------+-----------+
| JENNIFER | DAVIS     |
| JENNIFER | DAVIS     |
| JUDY     | DEAN      |
| JODIE    | DEGENERES |
| JULIANNE | DENCH     |
+----------+-----------+
5 rows in set (0.00 sec)
```

The column names specified in the two queries are different in this example. If you specify a column name from the second query in your order by clause, you will see the following error:

```sql
mysql> SELECT a.first_name fname, a.last_name lname
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
    -> UNION ALL
    -> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
    -> ORDER BY last_name, first_name;
```
```
ERROR 1054 (42S22): Unknown column 'last_name' in 'order clause'
```

I recommend giving the columns in both queries identical column aliases in order to avoid this issue.

### Set 연산자 우선 순위

복합 쿼리에 서로 다른 집합 연산자를 사용하는 쿼리가 세 개 이상 포함된 경우 원하는 결과를 얻기 위해 복합 문에 쿼리를 배치하는 순서에 대해 생각해야 합니다. 

다음 세 쿼리 복합 명령문을 고려하십시오.

```sql
mysql> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
    -> UNION ALL
    -> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'M%' AND a.last_name LIKE 'T%'
    -> UNION
    -> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%';
```
```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JENNIFER   | DAVIS     |
| JUDY       | DEAN      |
| JODIE      | DEGENERES |
| JULIANNE   | DENCH     |
| MARY       | TANDY     |
| MENA       | TEMPLE    |
+------------+-----------+
6 rows in set (0.00 sec)
```
이 복합 쿼리에는 고유하지 않은 이름 집합을 반환하는 세 개의 쿼리가 포함됩니다. 첫 번째 및 두 번째 쿼리는 모두 합집합 연산자로 구분되고 두 번째 및 세 번째 쿼리는 합집합 연산자로 구분됩니다. Union 및 Union 모든 연산자가 있는 위치에 큰 차이가 없는 것처럼 보일 수도 있지만 실제로는 차이를 만듭니다. 다음은 집합 연산자가 반대인 동일한 복합 쿼리입니다.

```sql
mysql> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
    -> UNION
    -> SELECT a.first_name, a.last_name
    -> FROM actor a
    -> WHERE a.first_name LIKE 'M%' AND a.last_name LIKE 'T%'
    -> UNION ALL
    -> SELECT c.first_name, c.last_name
    -> FROM customer c
    -> WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%';
```
```
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| JENNIFER   | DAVIS     |
| JUDY       | DEAN      |
| JODIE      | DEGENERES |
| JULIANNE   | DENCH     |
| MARY       | TANDY     |
| MENA       | TEMPLE    |
| JENNIFER   | DAVIS     |
+------------+-----------+
7 rows in set (0.00 sec)
```

결과를 보면 다른 집합 연산자를 사용할 때 복합 쿼리가 정렬되는 방식에 차이가 있음이 분명합니다. 일반적으로 3개 이상의 쿼리를 포함하는 복합 쿼리는 위에서 아래로 순서대로 평가되지만 다음과 같은 주의 사항이 있습니다.

ANSI SQL 사양은 교차 연산자가 다른 집합 연산자보다 우선하도록 요구합니다.

여러 쿼리를 괄호로 묶어 쿼리가 결합되는 순서를 지정할 수 있습니다.

MySQL은 아직 복합 쿼리에 괄호를 허용하지 않지만 다른 데이터베이스 서버를 사용하는 경우 다음과 같이 인접한 쿼리를 괄호로 묶어 복합 쿼리의 기본 위에서 아래로 처리를 재정의할 수 있습니다.

```sql
SELECT a.first_name, a.last_name
FROM actor a
WHERE a.first_name LIKE 'J%' AND a.last_name LIKE 'D%'
UNION
(SELECT a.first_name, a.last_name
 FROM actor a
 WHERE a.first_name LIKE 'M%' AND a.last_name LIKE 'T%'
 UNION ALL
 SELECT c.first_name, c.last_name
 FROM customer c
 WHERE c.first_name LIKE 'J%' AND c.last_name LIKE 'D%'
)
```

For this compound query, the second and third queries would be combined using the union all operator, then the results would be combined with the first query using the union operator.


## Test Your Knowledge

The following exercises are designed to test your understanding of set operations. See Appendix B for the answers to these exercises.

**Exercise 6-1**
If set A = {L M N O P} and set B = {P Q R S T}, what sets are generated by the following operations?

- A union B
- A union all B
- A intersect B
- A except B

**Exercise 6-2**
Write a compound query that finds the first and last names of all actors and customers whose last name starts with L.

**Exercise 6-3**
Sort the results from Exercise 6-2 by the last_name column.
