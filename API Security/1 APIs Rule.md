# 1. APIs Rule!

엔터프라이즈 API 채택은 기대 이상이었습니다. 거의 모든 산업 분야에서 API가 확산되고 있습니다. API가 없는 비즈니스는 인터넷이 없는 컴퓨터와 같다고 해도 과언이 아닙니다. API는 또한 사물 인터넷(IoT) 도메인에서 통신 채널을 구축하기 위한 기반입니다. 자동차에서 주방 가전에 이르기까지 수많은 장치가 API를 통해 서로 통신하기 시작했습니다.

세상은 그 어느 때보다 연결되어 있습니다. Facebook에서 Instagram의 사진을 공유하고, Twitter에서 Foursquare 또는 Yelp의 위치를 ​​공유하고, Facebook 담벼락에 트윗을 게시하고, Uber 모바일 앱을 통해 Google 지도에 연결하는 등 다양한 작업을 할 수 있습니다. 연결 목록은 무한합니다. 이 모든 것이 지난 몇 년 동안 급증한 공개 API 덕분에 가능했습니다. Expedia, Salesforce, eBay 및 기타 여러 회사는 API를 통해 연간 수익의 상당 부분을 창출합니다. API는 비즈니스 기능을 외부 세계에 노출하는 가장 멋진 방법이 되었습니다.

## API Economy

ACI 인포메이션 그룹이 발간한 인포그래픽1에 따르면, 현재 성장률로 세계 인터넷 경제 규모는 약 10조 달러에 이른다. 인터넷이 등장한 1984년에는 대학과 기업의 호스트 1000명을 연결했다. 거의 15년이 지난 1998년에는 전 세계적으로 인터넷 사용자 수가 5천만 명에 이르렀습니다. 그 이후 2009년에는 매직 넘버 10억 인터넷 사용자를 달성하는 데 11년이 걸렸습니다. 그 이후로 2배가 되는 데는 불과 3년이 걸렸고 2012년에는 21억에 도달했습니다. 2019년에는 세계 인구의 절반 이상인 약 43억 명이 인터넷을 사용합니다. 이 숫자는 Facebook 및 Google과 같은 인터넷 거물들이 취한 이니셔티브의 결과로 더욱 증가할 수 있습니다. 2013년에 시작된 Facebook의 Internet.org 이니셔티브는 기술 리더, 비영리 단체 및 지역 사회를 모아 인터넷에 접속할 수 없는 세계와 연결하는 것을 목표로 합니다. Google Loon은 Google이 시골 및 외딴 지역의 사람들을 연결하기 위해 시작한 프로젝트입니다. 우주의 가장자리를 여행하는 풍선 네트워크를 기반으로 하며 동남아시아의 2억 5천만 명의 연결성을 개선하는 것을 목표로 합니다.2


사물 인터넷의 성공 뒤에는 두 가지 핵심 요소가 있습니다. 하나는 API이고 다른 하나는 빅 데이터입니다. Wipro 산업 연구 위원회(Wipro Council for Industry Research)의 보고서4에 따르면 뉴욕에서 로스앤젤레스까지 보잉 737을 타고 6시간 동안 비행하면 120테라바이트의 데이터가 생성되어 비행기에서 수집되고 저장됩니다. 센서와 장치가 전 세계를 장악함에 따라 데이터를 저장, 관리 및 분석하는 적절한 방법이 필요합니다. 2014년까지 전 세계적으로 약 4제타바이트의 정보가 보관되었으며 2020년에는 그 수가 35제타바이트까지 증가할 것으로 예상됩니다.5 가장 흥미롭게도 오늘날 우리가 보유하고 있는 데이터의 90%가 마지막 몇 시간 동안 생성됩니다. 년. 사물 인터넷의 맥락에서 API의 역할은 빅 데이터만큼 중요합니다. API는 장치를 다른 장치 및 클라우드에 연결하는 접착제입니다.

사물 인터넷의 성공 뒤에는 두 가지 핵심 요소가 있습니다. 하나는 API이고 다른 하나는 빅 데이터입니다. Wipro 산업 연구 위원회(Wipro Council for Industry Research)의 보고서4에 따르면 뉴욕에서 로스앤젤레스까지 보잉 737을 타고 6시간 동안 비행하면 120테라바이트의 데이터가 생성되어 비행기에서 수집되고 저장됩니다. 센서와 장치가 전 세계를 장악함에 따라 데이터를 저장, 관리 및 분석하는 적절한 방법이 필요합니다. 2014년까지 전 세계적으로 약 4제타바이트의 정보가 보관되었으며 2020년에는 그 수가 35제타바이트까지 증가할 것으로 예상됩니다.5 가장 흥미롭게도 오늘날 우리가 보유하고 있는 데이터의 90%가 마지막 몇 시간 동안 생성됩니다. 년. 사물 인터넷의 맥락에서 API의 역할은 빅 데이터만큼 중요합니다. API는 장치를 다른 장치 및 클라우드에 연결하는 접착제입니다.

API 경제는 조직이 API를 사용하여 해당 비즈니스 도메인에서 수익을 올리거나 성공할 수 있는 방법에 대해 설명합니다. IBM은 API 경제가 2018년까지 2조 2천억 달러의 시장이 될 것으로 추정하고6, IBM Redbook, The Power of the API Economy(API 경제의 힘)7에서는 API 경제를 웹 API를 사용하는 서비스로서의 비즈니스 기능, 기능 또는 역량의 상업적 교환으로 정의합니다. 또한 기업이 웹 API를 수용하고 API 경제에 적극적으로 참여해야 하는 5가지 주요 이유를 찾습니다.

- API 생태계를 통해 제품 및 서비스에 고객을 유치하여 고객 기반을 확장합니다.

- 다양한 API, 귀하 및 제3자의 구성을 활용하여 혁신을 주도하십시오.

- 신제품의 가치 실현 시간과 시장 출시 시간을 개선합니다.

- 웹 API와의 통합을 개선합니다.

- 컴퓨팅의 새로운 시대를 위한 더 많은 가능성을 열고 유연한 미래를 준비합니다.

### Amazon

Amazon, Salesforce, Facebook, and Twitter are few very good examples for early entrants into the API economy, by building platforms for their respective capabilities. Today, all of them hugely benefit from the widespread ecosystems built around these platforms. Amazon was one of the very first enterprises to adopt APIs to expose its business functionalities to the rest. In 2006 it started to offer IT infrastructure services to businesses in the form of web APIs or web services. Amazon Web Services (AWS), which initially included EC2 (Elastic Compute Cloud) and S3 (Simple Storage Service), was a result of the thought process initiated in 2002 to lead Amazon’s internal infrastructure in a service-oriented manner.

The former Amazon employee, Steve Yegge, shared accidentally an Amazon internal discussion via his Google+ post, which became popular later. According to Yegge’s post,8 it all began with a letter from Jeff Bezos to the Amazon engineering team, which highlighted five key points to transform Amazon into a highly effective service-oriented infrastructure.

- All teams will henceforth expose their data and functionality through service interfaces.

- Teams must communicate with each other through these interfaces.

- There will be no other form of inter-process communication allowed: no direct linking, no direct reads of another team's data store, no shared memory model, no backdoors whatsoever. The only communication allowed is via service interface calls over the network.

- It doesn't matter what technology is used. HTTP, Corba, Pubsub, custom protocols—doesn't matter.

- All service interfaces, without exception, must be designed from the ground up to be externalizable. That is to say, the team must plan and design to be able to expose the interface to developers in the outside world. No exceptions.

This service-based approach leads Amazon to easily expand its business model from being a bookseller to a global retailer in selling IT services or cloud services. Amazon started exposing both EC2 and S3 capabilities as APIs, both in SOAP and REST (JSON over HTTP).

### Salesforce

Salesforce, which was launched in February 1999, is a leader in the software-as-a-service space today. The web API built around Salesforce capabilities and exposing it to the rest was a key success factor which took the company to the state where it is today. Salesforce kept on using platforms and APIs to fuel the innovation and to build a larger ecosystem around it.

### Uber

Google exposes most of its services via APIs. The Google Maps API, which was introduced in 2005 as a free service, lets many developers consume Google Maps to create much useful mashups by integrating with other data streams. Best example is the Uber. Uber is a transportation network company based out of San Francisco, USA, which also offers its services globally in many countries outside the United States. With the Uber mobile application on iOS or Android (see Figure 1-1), its customers, who set a pickup location and request a ride, can see on Google Maps where the corresponding taxi is. Also, from the Uber driver’s application, the driver can exactly pinpoint where the customer is. This is a great selling point for Uber, and Uber as a business hugely benefits from the Google Maps public API. At the same time, Google gets track of all the Uber rides. They know exactly the places of interests and the routes Uber customers take, which can be pumped into Google’s ad engine. Not just Uber, according to a report9 by Google, by 2013 more than 1 million active sites and applications were using Google Maps API.


Figure 1-1 Uber mobile app uses Google Maps

### Facebook

Facebook in 2007 launched the Facebook platform. The Facebook platform made most of the Facebook’s core capabilities available publicly to the application developers. According to the builtwith.com,10 the Facebook Graph API was used by 1 million web sites across the Internet, by October 2019. Figure 1-2 shows the Facebook Graph API usage over time. Most of the popular applications like Foursquare, Yelp, Instagram, and many more consume Facebook API to publish data to the user’s Facebook wall. Both parties mutually benefit from this, by expanding the adaptation and building a strong ecosystem.

 

Figure 1-2 Facebook Graph API usage statistics, the number of web sites over time

### Netflix

Netflix, a popular media streaming service in the United States with more than 150 million subscribers, announced its very first public API in 2008.11 During the launch, Daniel Jacobson, the Vice President of Edge Engineering at Netflix, explained the role of this public API as a broker, which mediates data between internal services and public developers. Netflix has come a long way since its first public API launch, and today it has more than a thousand types of devices supporting its streaming API.12 By mid-2014, there were 5 billion API requests generated internally (via devices used to stream the content) and 2 million public API requests daily.

### Walgreens

Walgreens, the largest drug retailing chain in the United States, opened up its photo printing and pharmacies to the public in 2012/2013, via an API.13 They started with two APIs, a QuickPrints API and a Prescription API. This attracted many developers, and dozens of applications were developed to consume Walgreens’ API. Printicular is one such application developed by MEA Labs, which can be used to print photos from Facebook, Twitter, Instagram, Google+, Picasa, and Flickr (see Figure 1-3). Once you pick your photos from any of these connected sites to be printed, you have the option to pick the printed photos from the closest Walgreens store or also can request to deliver. With the large number of applications built against its API, Walgreens was able to meet its expectations by enhancing customer engagements.

Figure 1-3 Printicular application written against the Walgreens API

### Governments

Not just the private enterprises but also governments started exposing its capabilities via APIs. On May 22, 2013, Data.gov (an initiative managed by the US General Services Administration, with the aim to improve public access to high-value, machine-readable datasets generated by the executive branch of the federal government) launched two initiatives to mark both the anniversary of the Digital Government Strategy and the fourth anniversary of Data.gov. First is a comprehensive listing of APIs that were released from across the federal government as part of the Digital Government Strategy. These APIs accelerated the development of new applications on everything from health, public safety, education, consumer protection, and many more topics of interest to Americans. This initiative also helped developers, where they can find all the government’s APIs in one place (http://api.data.gov), with links to API documentation and other resources.

### IBM Watson

APIs have become the key ingredients in building a successful enterprise. APIs open up the road to new business ecosystems. Opportunities that never existed before can be realized with a public API. In November 2013, for the first time, IBM Watson technology was made available as a development platform in the cloud, to enable a worldwide community of software developers to build a new generation of applications infused with Watson's cognitive computing intelligence.14 With the API, IBM also expected to create multiple ecosystems that will open up new market places. It connected Elsevier (world-leading provider of scientific, technical, and medical information products and services) and its expansive archive of studies on oncology care to both the medical expertise of Sloan Kettering (a cancer treatment and research institution founded in 1884) and Watson’s cognitive computing prowess. Through these links, IBM now provides physicians and nurse practitioners with information on symptoms, diagnosis, and treatment approaches.

### Open Banking

API adaptation has gone viral across verticals: retail, healthcare, financial, government, education, and in many more verticals. In the financial sector, the Open Bank15 project provides an open source API and app store for banks that empower financial institutions to securely and rapidly enhance their digital offerings using an ecosystem of third-party applications and services. As per Gartner,16 by 2016, 75% of the top 50 global banks have launched an API platform, and 25% have launched a customer-facing app store. The aim of Open Bank project is to provide a uniform interface, abstracting out all the differences in each banking API. That will help application developers to build applications on top of the Open Bank API, but still would work against any of the banks that are part of the Open Bank initiative. At the moment, only four German banks are onboarded, and it is expected to grow in the future.17 The business model behind the project is to charge an annual licensing fee from the banks which participate.

### Healthcare

The healthcare industry is also benefiting from the APIs. By November 2015, there were more than 200 medical APIs registered in ProgrammableWeb.18 One of the interesting projects among them, the Human API19 project, provides a platform that allows users to securely share their health data with developers of health applications and systems. This data network includes activity data recorded by pedometers, blood pressure measurements captured by digital cuffs, medical records from hospitals, and more. According to a report20 by GlobalData, the mobile health market was worth $1.2 billion in 2011, but expected to jump in value to reach $11.8 billion by 2018, climbing at an impressive compound annual growth rate (CAGR) of 39%. The research2guidance21 estimated the market for mobile health sensors to grow to $5.6 billion by 2017. Aggregating all these estimated figures, it’s more than obvious that the demand for medical APIs is only to grow in the near future.

### Wearables

Wearable industry is another sector, which exists today due to the large proliferation of APIs. The ABI Research22 estimates that the world will have 780 million wearables by 2019—everything from fitness trackers and smart watches to smart glasses and even heart monitors, in circulation. Most of the wearables come with low processing power and storages and talk to the APIs hosted in the cloud for processing and storage. For example, Microsoft Band, a wrist-worn wearable, which keeps track of your heart rate, steps taken, calories burned, and sleep quality, comes with the Microsoft Health mobile application. The wearable itself keeps tracks of the steps, distances, calories burned, and heart rate in its limited storage for a short period. Once it’s connected to the mobile application, via Bluetooth, all the data are uploaded to the cloud through the application. 

The Microsoft Health Cloud API23 allows you to enhance the experiences of your apps and services with real-time user data. These RESTful APIs provide comprehensive user fitness and health data in an easy-to-consume JSON format. This will enhance the ecosystem around Microsoft Band, as more and more developers can now develop useful applications around Microsoft Health API, hence will increase Microsoft Band adaptation. This will also let third-party application developers to develop a more useful application by mashing up their own data streams with the data that come from Microsoft Health API. RunKeeper, MyFitnessPal, MyRoundPro, and many more fitness applications have partnered with Microsoft Band in that effort, for mutual benefits.

### Business Models

Having a proper business model is the key to the success in API economy. The IBM Redbook, The Power of the API Economy,24 identifies four API business models, as explained here:

- Free model: This model focuses on the business adoption and the brand loyalty. Facebook, Twitter, and Google Maps APIs are few examples that fall under this model.

- Developer pays model: With this model, the API consumer or the developer has to pay for the usage. For example, PayPal charges a transaction fee, and Amazon lets developers pay only for what they use. This model is similar to the “Direct Revenue” model described by Wendy Bohner from Intel.25

- Developer is paid directly: This is sort of a revenue sharing model. The best example is the Google AdSense. It pays 20% to developers from revenue generated from the posted ads. Shopping.com is another example for revenue sharing business model. With Shopping.com API developers can integrate relevant product content with the deepest product catalogue available online and add millions of unique products and merchant offers to your site. It pays by the clicks.

- Indirect: With this model, enterprises build a larger ecosystem around it, like Salesforce, Twitter, Facebook, and many more. For example, Twitter lets developers build applications on top of its APIs. This benefits Twitter, by displaying sponsored tweets on end user’s Twitter timeline, on those applications. The same applies to Salesforce. Salesforce encourages third-party developers to extend its platform by developing applications on top of its APIs.

## The API Evolution

The concept behind APIs has its roots from the beginning of computing. An API of a component defines how others would interact with it. API stands for application programming interface, and it’s a technical specification for developers and architects. If you are familiar with the Unix or Linux operating system, the man command shouldn’t be something new. It generates the technical specification for each command in the system, which defines how a user can interact with it. The output from the man command can be considered as the API definition of the corresponding command. It defines everything you need to know to execute it, including the synopsis, description with all the valid input parameters, examples, and many more. The following command on a Unix/Linux or even on a Mac OS X environment will generate the technical definition of the ls command.

```
$ man ls
    NAME
    ls -- list directory contents
SYNOPSIS
    ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]
```

Going little further from there, if you are a computer science graduate or have read about operating systems, you surely have heard of system calls. System calls provide an interface to the operating system’s kernel, or a system call is how a program requests a service from the underlying operating system. Kernel is the core of the operating system, which wraps the hardware layer from the top-level applications (see Figure 1-4). If you want to print something from the browser, then the print command, which initiated from the browser, first has to pass through the kernel to reach the actual printer connected to the local machine itself, or remotely via the network. Where kernel executes its operations and provides services is known as the kernel space, while the top-level applications execute their operations and provide services in the user space. The kernel space is accessible for applications running in the user space only through system calls. In other words, system calls are the kernel API for the user space.

Figure 1-4 Operating system’s kernel

The Linux kernel has two types of APIs: one for the applications running in the user space and the other one is for its internal use. The API between the kernel space and user space can also be called the public API of the kernel, while the other as its private API.

Even at the top-level application, if you’ve worked with Java, .NET, or any other programming language, you’ve probably written code against an API. Java provides Java Database Connectivity (JDBC) as an API to talk to different heterogeneous database management systems (DBMSs), as shown in Figure 1-5. The JDBC API encapsulates the logic for how your application connects to a database; thus, the application logic doesn’t need to change whenever it connects to different databases. The database’s connectivity logic is wrapped in a JDBC driver and exposed as an API. To change the database, you need to pick the right JDBC driver.

Figure 1-5 JDBC API

An API itself is an interface. It’s the interface for clients that interact with the system or the particular component. Clients should only know about the interface and nothing about its implementation. A given interface can have more than one implementation, and a client written against the interface can switch between implementations seamlessly and painlessly. The client application and the API implementation can run in the same process or in different processes. If they’re running in the same process, then the call between the client and the API is a local one—if not, it’s a remote call. In the case of the JDBC API, it’s a local call. 

The Java client application directly invokes the JDBC API, 
implemented by a JDBC driver running in the same process. The following Java code snippet shows the usage of the JDBC API. This code has no dependency to the underneath database—it only talks to the JDBC API. In an ideal scenario, the program reads the name of the Oracle driver and the connection to the Oracle database from a configuration file, making the code completely clean from any database implementations.

We can also access APIs remotely. To invoke an API remotely, you need to have a protocol defined for interprocess communication. Java RMI, CORBA, .NET Remoting, SOAP, and REST (over HTTP) are some protocols that facilitate interprocess communication. Java RMI provides the infrastructure-level support to invoke a Java API remotely from a nonlocal Java virtual machine (JVM, which runs in a different process than the one that runs the Java API). 

The RMI infrastructure at the client side serializes all the requests from the client into the wire (also known as marshalling) and deserializes into Java objects at the server side by its RMI infrastructure (also known as unmarshalling); see Figure 1-6. This marshalling/unmarshalling technique is specific to Java. It must be a Java client to invoke an API exposed over Java RMI—and it’s language dependent.

Figure 1-6 Java RMI

The following code snippet shows how a Java client talks to a remotely running Java service over RMI. The Hello stub in the following code represents the service. The rmic tool, which comes with Java SDK, generates the stub against the Java service interface. We write the RMI client against the API of the RMI service.

SOAP-based web services provide a way to build and invoke a hosted API in a language- and platform-neutral manner. It passes a message from one end to the other as an XML payload. SOAP has a structure, and there are a large number of specifications to define its structure. The SOAP specification defines the request/response protocol between the client and the server. Web Services Description Language (WSDL) specification defines the way you describe a SOAP service. 

The WS-Security, WS-Trust, and WS-Federation specifications describe how to secure a SOAP-based service. WS-Policy provides a framework to build quality-of-service expressions around SOAP services. WS-SecurityPolicy defines the security requirements of a SOAP service in a standard way, built on top of the WS-Policy framework. The list goes on and on. SOAP-based services provide a highly decoupled, standardized architecture with policy-based governance. They do have all necessary ingredients to build a service-oriented architecture (SOA).

At least, that was the story a decade ago. The popularity of SOAP-based APIs has declined, mostly due to the inherent complexity of the WS-∗ standards. SOAP promised interoperability, but many ambiguities arose among different implementation stacks. To overcome this issue and promote interoperability between implementation stacks, the Web Services Interoperability (WS-I)26 organization came up with the Basic Profile for web services. The Basic Profile helps in removing ambiguities in web service standards. An API design built on top of SOAP should follow the guidelines Basic Profile defines.

> **Note**

> SOAP was initially an acronym that stood for Simple Object Access Protocol. From SOAP 1.2 onward, it is no longer an acronym.

In contrast to SOAP, REST is a design paradigm, rather than a rule set. Even though Roy Fielding, who first described REST in his PhD thesis,27 did not couple REST to HTTP, 99% of RESTful services or APIs today are based on HTTP. For the same reason, we could easily argue, REST is based on the rule set defined in the HTTP specification.

The Web 2.0 trend emerged in 2006–2007 and set a course to a simpler, less complex architectural style for building APIs. Web 2.0 is a set of economic, social, and technology trends that collectively formed the basis for the next generation of Internet computing. It was built by tens of millions of participants. The platform built around Web 2.0 was based on the simple, lightweight, yet powerful AJAX-based programming languages and REST—and it started to move away from SOAP-based services.

Modern APIs have their roots in both SOAP and REST. Salesforce launched its public API in 2000, and it still has support for both SOAP and REST. Amazon launched its web services API in 2002 with support for both REST and SOAP, but the early adoption rate of SOAP was very low. By 2003, it was revealed that 85% of Amazon API usage was on REST.28 ProgrammableWeb, a registry of web APIs, has tracked APIs since 2005. In 2005, ProgrammableWeb tracked 105 APIs, including Google, Salesforce, eBay, and Amazon. The number increased by 2008 to 1000 APIs, with growing interest from social and traditional media companies to expose data to external parties. There were 2500 APIs by the end of 2010. The online clothing and shoe shop Zappos published a REST API, and many government agencies and traditional brick-and-mortar retailers joined the party. The British multinational grocery and merchandise retailer Tesco allowed ordering via APIs. The photo-sharing application Instagram became the Twitter for pictures. The Face introduced facial recognition as a service. Twilio allowed anyone to create telephony applications in no time. The number of public APIs rose to 5000 by 2011; and in 2014 ProgrammableWeb listed out more than 14,000 APIs. In June 2019, ProgrammableWeb announced that the number of APIs it tracks eclipsed 22,000 (see Figure 1-7). At the same time, the trend toward SOAP has nearly died: 73% of the APIs on ProgrammableWeb by 2011 used REST, while SOAP was far behind with only 27%.29

Figure 1-7 The growth of APIs listed on ProgrammableWeb since 2005

The term API has existed for decades, but only recently has it been caught up in the hype and become a popular buzzword. The modern definition of an API mostly focused on a hosted, web-centric (over HTTP), public-facing service to expose useful business functionalities to the rest of the world. According to the Forbes magazine, an API is the primary customer interface for technology-driven products and services and a key channel for driving revenue and brand engagements. Salesforce, Amazon, eBay, Dropbox, Facebook, Twitter, LinkedIn, Google, Flickr, Yahoo, and most of the key players doing business online have an API platform to expose business functionalities.

## API Management

Any HTTP endpoint, with a well-defined interface to accept requests and generate responses based on certain business logic, can be treated as a naked API. In other words, a naked API is an unmanaged API. An unmanaged API has its own deficiencies, as listed here:

- There is no way to track properly the business owner of the API or track how ownership evolves over time.

- API versions are not managed properly. Introduction of a new API could possibly break all the existing consumers of the old API.

- No restriction on the audience. Anyone can access the API anonymously.

- No restriction on the number of API calls by time. Anyone can invoke the API any number of times, which could possibly cause the server hosting the API to starve all its resources.

- No tracking information at all. Naked APIs won’t be monitored and no stats will be gathered.

- Inability to scale properly. Since no stats are gathered based on the API usage, it would be hard to scale APIs based on the usage patterns.

- No discoverability. APIs are mostly consumed by applications. To build applications, application developers need to find APIs that suit their requirements.

- No proper documentation. Naked APIs will have a proper interface, but no proper documentation around that.

- No elegant business model. It’s hard to build a comprehensive business model around naked APIs, due to all the eight reasons listed earlier.

A managed must address all or most of the preceding concerns. Let’s take an example, the Twitter API. It can be used to tweet, get timeline updates, list followers, update the profile, and do many other things. None of these operations can be performed anonymously—you need to authenticate first. Let’s take a concrete example (you need to have cURL installed to try this, or you can use the Chrome Advanced REST client browser plug-in). The following API is supposed to list all the tweets published by the authenticated user and his followers. If you just invoke it, it returns an error code, specifying that the request isn’t authenticated:
```
\> curl https://api.twitter.com/1.1/statuses/home_timeline.json
{"errors":[{"message":"Bad Authentication data","code":215}]}
```
All the Twitter APIs are secured for legitimate access with OAuth 1.0 (which we discuss in detail in Appendix B). Even with proper access credentials, you can’t invoke the API as you wish. Twitter enforces a rate limit on each API call: within a given time window, you can only invoke the Twitter API a fixed number of times. This precaution is required for all public-facing APIs to minimize any possible denial of service (DoS) attacks. In addition to securing and rate limiting its APIs, Twitter also closely monitors them. Twitter API Health30 shows the current status of each API. Twitter manages versions via the version number (e.g., 1.1) introduced into the URL itself. Any new version of the Twitter API will carry a new version number, hence won’t break any of the existing API consumers. Security, rate limiting (throttling), versioning, and monitoring are key aspects of a managed business API. It also must have the ability to scale up and down for high availability based on the traffic.

Lifecycle management is another key differentiator between a naked API and a managed API. A managed API has a lifecycle from its creation to its retirement. A typical API lifecycle might flow through Created, Published, Deprecated, and Retired stages, as illustrated in Figure 1-8. To complete each lifecycle stage, there can be a checklist to be verified. For example, to promote an API from Created to Published, you need to make sure the API is secured properly, the documentation is ready, throttling rules are enforced, and so on. A naked business API, which only worries about business functionalities, can be turned into a managed API by building these quality-of-service aspects around it.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484220504/files/A323855_2_En_1_Fig8_HTML.jpg)

Figure 1-8 API lifecycle

The API description and discoverability are two key aspects of a managed API. For an API, the description has to be extremely useful and meaningful. At the same time, APIs need to be published somewhere to be discovered. A comprehensive API management platform needs to have at least three main components: a publisher, a store, and a gateway (see Figure 1-9). The API store is also known as the developer portal.

The API publisher provides tooling support to create and publish APIs. When an API is created, it needs to be associated with API documentation and other related quality-of-service controls. Then it’s published into the API store and deployed into the API gateway. Application developers can discover APIs from the store. ProgrammableWeb (www.programmableweb.com) is a popular API store that has more than 22,000 APIs at the time of this writing. You could also argue that ProgrammableWeb is simply a directory, rather than a store. A store goes beyond just listing APIs (which is what ProgrammableWeb does): it lets API consumers or application developers subscribe to APIs, and it manages API subscriptions. Further, an API store supports social features like tagging, commenting, and rating APIs. The API gateway is the one which takes all the traffic in runtime and acts as the policy enforcement point. The gateway checks all the requests that pass through it against authentication, authorization, and throttling policies. The statistics needed for monitoring is also gathered at the API gateway level. There are many open source and proprietary API management products out there that provide support for comprehensive API store, publisher, and gateway components.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484220504/files/A323855_2_En_1_Fig9_HTML.jpg)

Figure 1-9 API management platform

In the SOAP world, there are two major standards for service discovery. Universal Description, Discovery, and Integration (UDDI) was popular, but it's extremely bulky and didn’t perform to the level it was expected to. UDDI is almost dead today. The second standard is WS-Discovery, which provides a much more lightweight approach. Most modern APIs are REST-friendly. For RESTful services or APIs, there is no widely accepted standard means of discovery at the time of this writing. Most API stores make discovery via searching and tagging.

Describing a SOAP-based web service is standardized through the Web Service Definition Language (WSDL) specification. WSDL describes what operations are exposed through the web service and how to reach them. For RESTful services and APIs, there are two popular standards for description: Web Application Description Language (WADL) and Swagger. WADL is an XML-based standard to describe RESTful or HTTP-based services. Just as in WSDL, WADL describes the API and its expected request/response messages. Swagger is a specification and a complete framework implementation for describing, producing, consuming, and visualizing RESTful web services. With more than 350,000 downloads per month, of Swagger and Swagger-related tooling, the Swagger specification is promising to be the most widely used format for describing APIs.31 Figure 1-10 shows the Swagger definition of the Swagger Petstore API.32

[Swagger Petstore](https://petstore.swagger.io/)

Figure 1-10 Swagger definition of the Swagger Petstore API

Based on the Swagger 2.0 specification, the OpenAPI Initiative (OAI) has developed an OAI specification involving API consumers, developers, providers, and vendors, to define a standard, a language-agnostic interface for REST APIs. Google, IBM, PayPal, Intuit, SmartBear, Capital One, Restlet, 3scale, and Apigee got involved in creating the OpenAPI Initiative under the Linux foundation.

> **Managed APIS at Netflix**: 
>
> Netflix started its journey as a DVD rental service and then evolved into a video streaming platform and published its first API in 2008. In January 2010, Netflix API recorded 600 million requests (per month), and in January 2011, the number rose up to 20.7 billion, then again after a year, in January 2012, Netflix API was hit with 41.7 billion requests.33 Today, at the time of this writing, Netflix handles more than one third of the entire Internet traffic in North America. It’s a widespread service globally over 190 countries in 5 continents, with more than 139 million members. Netflix API is accessed by thousands of supported devices, generating billions of API requests per day.
>
> Even though Netflix API was initially developed as a way for external application developers to access Netflix’s catalogue, it soon became a key part in exposing internal functionality to living room devices supported by Netflix. The former is the Netflix’s public API, while the latter is its private API. The public API, when compared with the private API, only attracted a small number of traffic. At the time Netflix decided to shut down the public API in November 2011, it only attracted 0.3% of the total API traffic.34
>
> Netflix uses its own API gateway, Zuul, to manage all its API traffic.35 Zuul is the front door for all the requests from devices and web sites to the back end of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency, and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.36

### The Role of APIs in Microservices

Going back to the good old days, there was an unambiguous definition for API vs. service. An API is the interface between two parties or two components. These two parties/components can communicate within a single process or between different processes. A service is a concrete implementation of an API using one of the technologies/standards available. The implementation of an API that is exposed over SOAP is a SOAP service. Similarly, the implementation of an API that is exposed as JSON over HTTP is a RESTful service.

Today, the topic, API vs. service, is debatable, as there are many overlapping areas. One popular definition is that an API is external facing, whereas a service is internal facing (see Figure 1-11). An enterprise uses an API whenever it wants to expose useful business functionality to the outside world through the firewall. This, of course, raises another question: why would a company want to expose its precious business assets to the outside world through an API? Twitter once again is the best example. It has a web site that allows users to log in and tweet from there. At the same time, anything that can be done through the web site can also be done via Twitter’s API. As a result, third parties develop applications against the Twitter API; there are mobile apps, browser plug-ins, and desktop apps. This has drastically reduced traffic to the Twitter web site. Even today, the web site doesn’t have a single advertisement (but as sponsored tweets on the usual twitter stream). If there was no public API, Twitter could easily have built an advertising platform around the web site, just as how Facebook did. However, having a public API helped to build a strong ecosystem around Twitter.

 

Figure 1-11 API vs. service. An API is external facing

Exposing corporate data via an API adds value. It gives access to the data, not just for corporate stakeholders but also for a larger audience. Limitless innovative ideas may pop up and, in the end, add value to the data. Say we have a pizza dealer with an API that returns the number of calories for a given pizza type and the size. You can develop an application to find out how many pizzas a person would have to eat per day to reach a body mass index (BMI) in the obesity range.

Even though APIs are known to be public, it’s not a strict requirement. Most of the APIs started as public APIs and became the public face of the enterprise. At the same time, private APIs (not exposed to the public) proliferated within enterprises to share functionalities within it, between different components. In that case, the differentiator between an API and a service is not just its audience. In practice, most of the service implementations are exposed as APIs. In that case, API defines the contract between the service and the outside world (not necessarily public).

Microservices is the most trending buzzword at the time of this writing. Everyone talks about microservices, and everyone wants to have microservices implemented. The term “microservice” was first discussed at a software architects workshop in Venice, in May 2011. It’s being used to explain a common architectural style they’ve been witnessing for some time. Later, after a year in May 2012, the same team agreed that the “microservice” is the best-suited term to call the previously discussed architectural style. At the same time, in March 2012, James Lewis went ahead and presented some of the ideas from the initial discussion in Venice at the 33rd Degree conference in Krakow, Poland.37

> **Note**
> The abstract of James Lewis’ talk on “Microservices – Java, the Unix Way,” which happened to be the very first public talk on Microservices, in March 2012:

“Write programs that do one thing and do it well. Write programs to work together” was accepted 40 years ago, yet we have spent the last decade building monolithic applications, communicating via bloated middleware and with our fingers crossed that Moore’s Law keeps helping us out. There is a better way.

>
> Microservices. In this talk, we will discover a consistent and reinforcing set of tools and practices rooted in the Unix philosophy of small and simple. Tiny applications, communicating via the web’s uniform interface with single responsibilities and installed as well-behaved operating system services. So, are you sick of wading through tens of thousands of lines of code to make a simple one-line change? Of all that XML? Come along and check out what the cool kids are up to (and the cooler gray beards).

One can easily argue that a microservice is SOA done right. Most of the concepts we discussed today, related to microservices, are borrowed from SOA. SOA talks about an architectural style based on services. According to the Open Group definition, a service is a logical representation of a repeatable business activity that has a specified outcome and is self-contained, may be composed of other services; the implementation acts as a black box to the service consumers.38 SOA brings the much-needed agility to business to scale and interoperate. However, over the past, SOA became a hugely overloaded term. Some people defined SOA under the context of SOAP-based web services, and others used to think SOA is all about an enterprise service bus (ESB). This led Netflix to call microservices as fine-grained SOA, at the initial stage.

>I don’t really care whether it’s public or private. We used to call the things we were building on the cloud “cloud-native” or “fine-grained SOA,” and then the ThoughtWorks people came up with the word “microservices.” It’s just another name for what we were doing anyways, so we just started calling it microservices, as well.39
>
>— Adrian Cockcroft, former cloud architect at Netflix

### Nine Characteristics of a Microservice

Martin Fowler and James Lewis, introducing microservices,40 identify nine characteristics in a well-designed microservice, as briefly explained in the following:

- **Componentization via services**: In microservices, the primary way of componentizing will be via services. This is a bit different from the traditional componentizing via libraries. A library in the Java world is a jar file, and in .NET world, it’s a DLL file. A library can be defined as a component isolated to perform some specific task and plugged into the main program via in-memory function calls. In microservices world, these libraries mostly act as a proxy to a remote service running out of process.

- **Organized around business capabilities**: In most of the monolithic applications we see today, the layering is based on the technology not around the business capabilities. The user interface (UI) design team works on building the user interface for the application. They are the experts on HTML, JavaScript, Ajax, HCI (human-computer interaction), and many more. Then we have database experts who take care of database schema design and various application integration technologies, like JDBC, ADO.NET, and Hibernate. Then we have server-side logic team who write the actual business logic and also are the experts on Java, .NET, and many more server-side technologies. With the microservices approach, you build cross-functional, multidisciplined teams around business capabilities.

- **Products not projects**: The objectives of a project team are to work according to a project plan, meet the set deadlines, and deliver the artifacts at the end of the project. Once the project is done, the maintenance team takes care of managing the project from there onward. It is estimated that 29% of an IT budget is spent on new system development, while 71% is spent on maintaining existing systems and adding capacity to those systems.41 To avoid such wastage and to improve the efficiency throughout the product lifecycle, Amazon introduced the concept—you build it, you own it. The team, which builds the product, will own it forever. This brought in the product mentality and made the product team responsible for a given business functionality. Netflix, one of the very early promoters of microservices, treats each of their API as a product.

- **Smart endpoints and dumb pipes**: Each microservice is developed for a well-defined scope. Once again, the best example is Netflix.42 Netflix started with a single monolithic web application called netflix.war in 2008, and later in 2012, as a solution to address vertical scalability concerns, they moved into a microservices-based approach, where they have hundreds of fine-grained microservices today. The challenge here is how microservices talk to each other. Since the scope of each microservice is small (or micro), to accomplish a given business requirement, microservices have to talk to each other. Each microservice would be a smart endpoint, which exactly knows how to process an incoming request and generate the response. The communication channels between microservices act as dumb pipes. This is similar to the Unix pipes and filters architecture. For example, the ps –ax command in Unix will list out the status of currently running processes. The grep Unix command will search any given input files, selecting lines that match one or more patterns. Each command is smart enough to do their job. We can combine both the commands with a pipe. For example, ps –ax | grep 'apache' will only list out the processes that matches the search criteria ‘apache’. Here the pipe (|) acts as dumb—which basically takes the output from the first command and hands it over to the other. This is one of the main characteristics of a microservice design.

- **Decentralized governance**: Most of the SOA deployments follow the concept of centralized governance. The design time governance and the runtime governance are managed and enforced centrally. The design time governance will look into the aspects such as whether the services passed all the unit tests, integration tests, and coding conventions, secured with accepted security policies and many more, before promoting from the developer phase to the QA (quality assurance) phase. In a similar way, one can enforce more appropriate checklists to be evaluated before the services are promoted from QA to staging and from staging to production. The runtime governance will worry about enforcing authentication policies, access control policies, and throttling policies in the runtime. With the microservices-based architecture, each service is designed with its own autonomy and highly decoupled from each other. The team behind each microservice can follow their own standards, tools, and protocols. This makes a decentralized governance model more meaningful for microservices architecture.

- **탈중앙화 데이터 관리**: In a monolithic application, all the components in it talk to a single database. With the microservices design, where each distinguished functional component is developed into a microservice, based on their business capabilities, will have its own database—so each such service can scale end to end without having any dependency on other microservices. This approach can easily add overhead in distributed transaction management, as data resides in multiple heterogeneous database management systems.

- **Infrastructure automation**: Continuous deployment and continuous delivery are two essential ingredients in infrastructure automation. Continuous deployment extends continuous delivery and results in every build that passes automated test gates being deployed into production, while with continuous delivery, the decision to deploy into the production setup is taken based on the business need.43 Netflix, one of the pioneers in APIs and microservices, follows the former approach, the continuous deployment. With the continuous deployment, the new features need not be sitting on a shelf. Once they have gone through and passed all the tests, they are ready to be deployed in production. This also avoids deploying a large set of new features at one go, hence doing minimal changes to the current setup and the user experience. Infrastructure automation does not have a considerable difference between monolithic applications and microservices. Once the infrastructure is ready, it can be used across all the microservices.

- **Design for failure**: The microservices-based approach is a highly distributed setup. In a distributed setup, failures are inevitable. No single component can guarantee 100% uptime. Any service call may fail due to various reasons: the transport channel between the services could be down, the server instance which hosts the service may be down, or even the service itself may be down. This is an extra overhead on microservices, compared to monolithic applications. Each microservice should be designed in a way to handle and tolerate these failures. In the entire microservices architecture, the failure of one service should ideally have zero or minimal impact on the rest of the running services. Netflix developed a set of tools called Simian Army,44 based on the success of its Chaos Monkey, to simulate failure situations under a controlled environment to make sure the system can gracefully recover.

- **Evolutionary design**: The microservices architecture inherently supports the evolutionary design. Unlike in monolithic applications, with microservices the cost of upgrading or replacing an individual component is extremely low, since they’ve been designed to function independently or in a loosely coupled manner.

Netflix is one of the pioneers in microservices adoption. Not just Netflix, GE, HP, Equinox Inc, PayPal, Capital One Financial Corp, Goldman Sachs Group Inc, Airbnb, Medallia, Square, Xoom Corp, and many more are early adopters of microservices.45 Even though microservices became a buzzword quite recently, some of the design principles brought forward by the microservices architecture were there for some time. It’s widely believed that Google, Facebook, and Amazon were using microservices internally for several years—when you do a Google search, it calls out roughly 70 microservices before returning back the results.

Just like in the case of API vs. service, the differentiator between an API and a microservice also relies on the audience. APIs are known to be public facing, while microservices are used internally. Netflix, for example, has hundreds of microservices, but none of them are exposed outside. The Netflix API still acts as their public-facing interface, and there is a one-to-many relationship between the Netflix API and its microservices. In other words, one API could talk to multiple microservices to cater a request generated by one of the devices supported by Netflix. Microservices have not substituted APIs—rather they work together.

## Summary

- The API adoption has grown rapidly in the last few years, and almost all the cloud service providers today expose public managed APIs.

- In contrast to naked APIs, the managed APIs are secured, throttled, versioned, and monitored.

- An API store (or a developer portal), API publisher, and API gateway are the three key ingredients in building an API management solution.

- Lifecycle management is a key differentiator between a naked API and a managed API. A managed API has a lifecycle from its creation to its retirement. A typical API lifecycle might flow through Created, Published, Deprecated, and Retired stages.

- Microservices have not substituted APIs—rather they work together.

