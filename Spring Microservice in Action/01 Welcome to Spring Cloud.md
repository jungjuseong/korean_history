# 1 클라우드에 오신 것을 환영합니다

이 장에서는 다음을 다룹니다.

- 마이크로서비스 아키텍처 이해
- 기업이 마이크로서비스를 사용하는 이유 이해
- 마이크로서비스 구축을 위해 Spring, Spring Boot 및 Spring Cloud 사용
- 클라우드 및 클라우드 기반 컴퓨팅 모델 이해

새로운 아키텍처를 구현하는 것은 쉬운 일이 아닙니다. 애플리케이션 확장성, 서비스 검색, 모니터링, 분산 추적, 보안, 관리 등과 같은 많은 문제가 수반됩니다. 이 책은 Spring의 마이크로서비스 세계를 소개하고, 이러한 모든 문제를 해결하는 방법을 가르치고, 비즈니스 애플리케이션을 위한 마이크로서비스를 고려할 때 고려해야 할 절충안을 보여줍니다. 진행하면서 Spring Cloud, Spring Boot, Swagger, Docker, Kubernetes, ELK(Elasticsearch, Logstash, Kibana), Stack, Grafana, Prometheus 등과 같은 기술을 사용하여 마이크로서비스 애플리케이션을 구축하는 방법을 배우게 됩니다.

당신이 자바 개발자라면 이 책은 전통적인 Spring 애플리케이션 구축에서 클라우드에 배포할 수 있는 마이크로서비스 애플리케이션으로의 원활한 마이그레이션 경로를 제공할 것입니다. 이 책은 마이크로서비스 아키텍처를 구현하는 방법에 대한 자세한 내용을 제공하기 위해 실제 예제, 다이어그램 및 설명 텍스트를 사용합니다.

마지막으로 Spring Boot 및 Spring Cloud를 사용하여 유연하고 현대적이며 자율적인 마이크로 서비스 기반 비즈니스 애플리케이션을 생성하기 위해 클라이언트 로드 밸런싱, 동적 확장, 분산 추적 등과 같은 기술 및 기술을 구현하는 방법을 배우게 됩니다. 또한 Kubernetes, Jenkins 및 Docker와 같은 기술을 적용하여 비즈니스와의 지속적인 전달 및 통합을 달성하기 위해 자체 빌드/배포 파이프라인을 생성할 수 있습니다.

## 1.1 마이크로서비스 아키텍처로의 진화

소프트웨어 아키텍처는 구조, 작동 및 상호 작용을 설정하는 모든 기본 부분을 나타냅니다. 소프트웨어 구성 요소. 이 책은 잘 정의된 적은 수의 작업을 수행하고 네트워크를 통해 메시지를 사용하여 통신하는 느슨하게 결합된 소프트웨어 서비스로 구성된 마이크로서비스 아키텍처를 만드는 방법을 설명합니다. 마이크로서비스와 다른 일반적인 아키텍처 간의 차이점을 고려하여 시작하겠습니다.

### 1.1.1 N 계층 아키텍처

일반적인 유형의 엔터프라이즈 아키텍처는 다계층 또는 n계층 아키텍처입니다. 이 디자인에서 애플리케이션은 UI, 서비스, 데이터, 테스트 등과 같은 고유한 책임과 기능을 가진 여러 계층으로 나뉩니다. 예를 들어, 애플리케이션을 생성할 때 UI용으로 특정 프로젝트 또는 솔루션을 만든 다음 서비스용으로, 데이터 계층용으로 또 하나를 만드는 식입니다. 결국, 결합하여 전체 응용 프로그램을 만드는 여러 프로젝트를 갖게 됩니다. 대규모 엔터프라이즈 시스템의 경우 n계층 애플리케이션은 다음과 같은 많은 이점을 제공합니다.

- N 계층 응용 프로그램은 문제를 잘 구분하여 UI(사용자 인터페이스), 데이터 및 비즈니스 논리와 같은 영역을 개별적으로 고려할 수 있습니다.

- 팀이 n 계층 응용 프로그램의 다른 구성 요소에서 독립적으로 작업하기 쉽습니다.

- 이것은 잘 알려진 엔터프라이즈 아키텍처이기 때문에 n-티어 프로젝트를 위한 숙련된 개발자를 찾기가 비교적 쉽습니다.

N 계층 애플리케이션에는 다음과 같은 단점도 있습니다.

- 변경하려면 전체 응용 프로그램을 중지했다가 다시 시작해야 합니다.

- 메시지는 계층을 통해 위아래로 전달되는 경향이 있어 비효율적일 수 있습니다.

- 일단 배포되면 대규모 n계층 애플리케이션을 리팩토링하는 것이 어려울 수 있습니다.

이 책에서 논의할 주제 중 일부는 n 계층 애플리케이션과 직접 관련이 있지만 종종 마이크로서비스라고 하는 다른 공통 아키텍처와 마이크로서비스를 구별하는 데 더 직접적으로 초점을 맞출 것입니다.

### 1.1.2 모놀리식 아키텍처란 무엇입니까?

많은 중소 규모의 웹 기반 애플리케이션은 모놀리식 아키텍처 스타일을 사용하여 구축됩니다. 모놀리식 아키텍처에서 애플리케이션은 배포 가능한 단일 소프트웨어 아티팩트로 제공됩니다. 모든 UI, 비즈니스 및 데이터베이스 액세스 로직은 고유한 애플리케이션으로 함께 패키징되어 애플리케이션 서버에 배포됩니다. 그림 1.1은 이 애플리케이션의 기본 아키텍처를 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F01_Huaylupo.png)

그림 1.1 단조식 애플리케이션은 코드를 전체 단위로 빌드, 테스트 및 배포해야 하기 때문에 여러 개발 팀이 제공 날짜를 동기화하도록 합니다.

애플리케이션이 단일 작업 단위로 배포될 수 있지만 단일 애플리케이션에서 작업하는 여러 개발 팀이 있는 경우가 많습니다. 각 개발 팀은 일반적으로 특정 고객을 대상으로 하는 애플리케이션의 개별 부분을 담당합니다. 예를 들어, UI/UX, 고객, 데이터 웨어하우스, 재무 관계자 등을 포함한 여러 팀의 조정을 포함하는 사내 맞춤형 고객 관계 관리(CRM) 애플리케이션이 있는 시나리오를 상상해 보십시오.

마이크로서비스 아키텍처 지지자들은 모놀리식 애플리케이션을 부정적인 용어로 설명하기도 하지만 이는 종종 훌륭한 선택입니다. 모놀리스는 n계층 또는 마이크로서비스와 같은 복잡한 아키텍처보다 구축 및 배포가 더 쉽습니다. 사용 사례가 잘 정의되어 있고 변경될 가능성이 낮은 경우 모놀리스로 시작하는 것이 좋습니다.

그러나 애플리케이션의 크기와 복잡성이 증가하기 시작하면 모놀리스를 관리하기가 어려워질 수 있습니다. 모놀리스에 대한 각 변경은 응용 프로그램의 다른 부분에 계단식 영향을 줄 수 있으며, 이로 인해 특히 프로덕션 시스템에서 시간과 비용이 많이 소요될 수 있습니다. 세 번째 옵션인 마이크로서비스 아키텍처는 더 큰 유연성과유지 보수성.

### 1.1.3 마이크로서비스란 무엇입니까?

NS 마이크로서비스의 개념은 처음에 대규모 모놀리식 응용 프로그램을 확장하려는(기술적으로나 조직적으로) 많은 문제에 대한 직접적인 대응으로 소프트웨어 개발 커뮤니티의 의식에 스며들었습니다. 마이크로서비스는 작고 느슨하게 결합 된 분산 서비스입니다. 마이크로서비스를 사용하면 광범위한 애플리케이션을 좁은 범위로 정의된 책임과 함께 관리하기 쉬운 구성 요소로 분해할 수 있습니다. 마이크로서비스는 크고 잘 정의된 작은 조각으로 분해하여 대규모 코드베이스의 기존 복잡성 문제를 해결하는 데 도움이 됩니다.

마이크로서비스에 대해 생각할 때 수용해야 하는 핵심 개념은 분해와 묶음 해제입니다. 애플리케이션의 기능은 서로 완전히 독립적이어야 합니다. 앞서 언급한 CRM 애플리케이션을 마이크로서비스로 분해하면 그림 1.2와 같이 보일 수 있습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F02_Huaylupo.png)

그림 1.2 마이크로서비스 아키텍처를 사용하여 CRM 애플리케이션은 완전히 독립적인 마이크로서비스 세트로 분해되어 각 개발 팀이 고유한 속도로 이동할 수 있습니다.

그림 1.2는 각 팀이 서비스 코드와 서비스 인프라를 완전히 소유하는 방법을 보여줍니다. 코드, 소스 제어 리포지토리 및 인프라(앱 서버 및 데이터베이스)가 이제 애플리케이션의 다른 부분과 완전히 독립적이기 때문에 서로 독립적으로 빌드, 배포 및 테스트할 수 있습니다. 요약하자면 마이크로서비스 아키텍처에는 다음과 같은 특징이 있습니다.

- 응용 프로그램 논리는 잘 정의되고 조정된 책임 경계가 있는 작은 구성 요소로 나뉩니다.

- 각 구성 요소는 작은 책임 영역을 가지며 다른 구성 요소와 독립적으로 배포됩니다. 단일 마이크로 서비스는 비즈니스 도메인의 한 부분을 담당합니다.

- 마이크로서비스는 서비스 소비자와 서비스 제공자 간의 데이터 교환을 위해 HTTP 및 JSON과 같은 경량 통신 프로토콜을 사용합니다.

- 마이크로서비스 애플리케이션은 항상 기술 중립적 형식(JSON이 가장 일반적임)으로 통신하기 때문에 서비스의 기본 기술 구현은 관련이 없습니다. 이는 마이크로서비스 접근 방식을 사용하여 구축된 애플리케이션이 여러 언어와 기술로 구축될 수 있음을 의미합니다.

- 마이크로서비스는 작고 독립적이며 분산된 특성으로 인해 조직에서 책임 영역이 잘 정의된 소규모 개발 팀을 가질 수 있습니다. 이러한 팀은 애플리케이션 제공과 같은 단일 목표를 위해 작업할 수 있지만 각 팀은 작업 중인 서비스에 대해서만 책임이 있습니다.

그림 1.3은 일반적인 소규모 전자 상거래에 대한 모놀리식 설계와 마이크로서비스 접근 방식을 비교합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F03_Huaylupo.png)

그림 1.3 모놀리식 아키텍처와 마이크로서비스 아키텍처 비교

### 1.1.4 애플리케이션 구축 방식을 변경하는 이유는 무엇입니까?

국내 시장에 서비스를 제공하던 중 갑자기 글로벌 고객 기반에 다가갈 수 있다는 사실을 알게 되었습니다. 그러나 더 넓은 글로벌 고객 기반과 함께 전 세계적인 경쟁도 수반됩니다. 더 많은 경쟁은 개발자가 애플리케이션 구축에 대해 생각해야 하는 방식에 영향을 미칩니다. 예를 들어:

- 복잡성이 높아졌습니다. 고객은 조직의 모든 부분이 자신이 누구인지 알고 있기를 기대합니다. 그러나 단일 데이터베이스와 통신하고 다른 애플리케이션과 통합되지 않는 "사일로" 애플리케이션은 더 이상 표준이 아닙니다. 오늘날의 애플리케이션은 회사의 데이터 센터 내부뿐만 아니라 외부 인터넷 서비스 공급자 내부에 있는 여러 서비스 및 데이터베이스와 통신해야 합니다.

- 고객은 더 빠른 배송을 원합니다. 고객은 더 이상 소프트웨어 패키지의 다음 연례 릴리스를 기다리기를 원하지 않습니다. 대신, 그들은 새로운 기능이 몇 주(또는 며칠) 만에 빠르게 릴리스될 수 있도록 소프트웨어 제품의 기능이 번들로 해제되기를 기대합니다.

- 고객은 또한 안정적인 성능과 확장성을 요구합니다. 글로벌 애플리케이션은 애플리케이션에서 처리할 트랜잭션 수와 해당 트랜잭션 볼륨에 도달할 시기를 예측하는 것을 극도로 어렵게 만듭니다. 애플리케이션은 여러 서버에서 빠르게 확장한 다음 볼륨이 지나면 원활하게 다시 축소해야 합니다.

- 고객은 애플리케이션을 사용할 수 있기를 기대합니다. 고객은 클릭 한 번으로 경쟁업체와 연결되므로 회사의 애플리케이션은 복원력이 높아야 합니다. 응용 프로그램의 한 부분에서 발생하는 오류나 문제로 인해 전체 응용 프로그램이 중단되어서는 안 됩니다.

이러한 기대를 충족시키기 위해 애플리케이션 개발자는 확장성과 중복성이 높은 애플리케이션을 구축하려면 애플리케이션을 서로 독립적으로 구축 및 배포할 수 있는 소규모 서비스로 분할해야 한다는 수수께끼를 받아들여야 합니다. 애플리케이션을 더 작은 서비스로 "분할"하고 이를 단일 모놀리식 아티팩트에서 멀리 옮기면 다음과 같은 시스템을 구축할 수 있습니다.

- 유연성 — 새로운 기능을 신속하게 제공하기 위해 분리된 서비스를 구성 및 재배열할 수 있습니다. 작업하는 코드 단위가 작을수록 변경이 덜 복잡하고 코드를 테스트하고 배포하는 데 걸리는 시간이 줄어듭니다.

- 탄력성 — 분리된 서비스는 애플리케이션이 더 이상 단일 "진흙구이"가 아님을 의미합니다. 여기서 애플리케이션의 한 부분이 저하되어 전체 애플리케이션이 실패하게 됩니다. 장애는 애플리케이션의 작은 부분에 국한될 수 있으며 전체 애플리케이션이 종료되기 전에 억제될 수 있습니다. 이렇게 하면 복구할 수 없는 오류가 발생하는 경우 응용 프로그램이 정상적으로 성능이 저하될 수도 있습니다.

- 확장성 — 분리된 서비스를 여러 서버에 수평으로 쉽게 배포할 수 있으므로 기능/서비스를 적절하게 확장할 수 있습니다. 응용 프로그램의 모든 논리가 얽혀 있는 모놀리식 응용 프로그램을 사용하면 응용 프로그램 의 작은 부분만 병목 현상이 발생하더라도 전체 응용 프로그램을 축소해야 합니다. 소규모 서비스의 경우 확장이 현지화되고 훨씬 더 비용 효율적입니다.

이를 위해 마이크로서비스에 대한 논의를 시작합니다. 여정을 시작할 때 다음 사항을 염두에 두십시오.

작고 단순하며 분리된 서비스 = 확장 가능하고 탄력적이며 유연한 애플리케이션

시스템과 조직이 마이크로서비스 접근 방식의 이점을 누릴 수 있다는 점을 이해하는 것이 중요합니다. 조직에서 이익을 얻으려면 Conway의 법칙을 적용할 수 있습니다.반대로. 이 법은 회사의 의사 소통과 구조를 향상시킬 수있는 몇 가지 사항을 나타냅니다.

Conway의 법칙(1968년 4월에 Melvin R. Conway가 "How Do Committees Invent" 기사에서 작성)에 따르면 "조직은 시스템을 설계합니다. . 이러한 조직의 커뮤니케이션 구조를 모방한 디자인을 생산하도록 제한되어 있습니다." 기본적으로 이는 팀이 팀 내에서 그리고 다른 팀과 의사 소통하는 방식이 그들이 생산하는 코드에 직접 반영된다는 것을 의미합니다.

Conway의 법칙을 역으로 적용하면( 역 Conway 기동 이라고도 함)) 마이크로 서비스 아키텍처를 기반으로 조직 구조를 설계하고 구현하기 위해 느슨하게 결합되고 자율적인 팀을 만들어 애플리케이션의 커뮤니케이션, 안정성 및 조직 구조가 향상됩니다.

# 1.2 Spring을 사용한 마이크로서비스

Spring은 자바 기반 애플리케이션을 구축하기 위한 가장 인기 있는 개발 프레임워크가 되었습니다. 기본적으로 Spring은 종속성 주입 개념을 기반으로 합니다. 의존성 주입기구서로에 대해 "알기" 위해 해당 객체를 하드코딩하는 대신 규칙(및 주석)을 통해 애플리케이션 내 객체 간의 관계를 외부화하여 대규모 Java 프로젝트를 보다 효율적으로 관리할 수 있습니다. Spring은 애플리케이션의 다른 Java 클래스 사이에서 중개자 역할을 하며 종속성을 관리합니다. Spring을 사용하면 기본적으로 함께 결합되는 레고 블록 세트처럼 코드를 조립할 수 있습니다.

Spring 프레임워크에서 인상적이고 개발 커뮤니티에 대한 증거는 관련성을 유지하고 스스로를 재창조하는 능력입니다. Spring 개발자는 많은 개발 팀이 애플리케이션의 프리젠테이션, 비즈니스 및 데이터 액세스 로직이 함께 패키지화되고 단일 아티팩트로 배포되는 모놀리식 애플리케이션에서 멀어지고 있음을 빠르게 확인했습니다. 대신 개발 팀이 소규모 서비스를 클라우드에 신속하게 배포할 수 있는 고도로 분산된 모델로 이동하고 있다는 사실을 알게 되었습니다. 이러한 변화에 대응하여 Spring 개발자는 Spring Boot와 Spring Cloud라는 두 가지 프로젝트를 시작했습니다.

Spring Boot는 Spring 프레임워크를 다시 구상한 것입니다. Spring Boot는 Spring의 핵심 기능을 수용하지만 Spring에서 발견되는 많은 "엔터프라이즈" 기능을 제거하고 대신 Java 기반, REST 지향에 맞춰진 프레임워크를 제공합니다.) 마이크로 서비스. 몇 가지 간단한 주석을 사용하여 Java 개발자는 외부 애플리케이션 컨테이너 없이 패키징 및 배포할 수 있는 REST 서비스를 빠르게 구축할 수 있습니다.

> **NOTE** 3장에서 REST를 더 자세히 다루지만 REST의 핵심 개념은 서비스가 서비스의 핵심 작업을 나타내기 위해 HTTP(GET, POST, PUT 및 DELETE)의 사용을 수용해야 하고 다음을 사용해야 한다는 것입니다. 서비스에서 데이터를 요청하고 수신하기 위한 JSON과 같은 경량의 웹 지향 데이터 직렬화 프로토콜입니다.

Spring Boot의 주요 기능은 다음과 같습니다.

- 응용 프로그램 배포의 복잡성을 피하기 위한 내장 웹 서버: Tomcat(기본값), Jetty 또는 Undertow.

이것은 Spring Boot의 필수 구성 요소 중 하나입니다. 선택한 웹 서버는 배포 가능한 JAR의 일부입니다. Spring Boot 애플리케이션의 경우 앱을 배포하기 위한 유일한 요구 사항은 서버에 Java가 설치되어 있어야 합니다.

- 프로젝트(스타터)로 빠르게 시작하기 위한 제안 구성.

- 가능하면 언제든지 Spring을 기능적으로 자동 구성합니다.

- 생산 준비가 된 다양한 기능(예: 메트릭, 보안, 상태 확인, 외부 구성 등).

Spring Boot를 사용하면 마이크로서비스에 다음과 같은 이점이 있습니다.

- 개발 시간을 단축하고 효율성과 생산성을 높입니다.

- 웹 애플리케이션을 실행하기 위한 임베디드 HTTP 서버 제공

- 많은 상용구 코드 작성을 피할 수 있습니다.

- Spring 생태계와의 통합(Spring Data, Spring Security, Spring Cloud 등 포함)

- 다양한 개발 플러그인 세트 제공

마이크로서비스가 클라우드 기반 애플리케이션을 구축하기 위한 보다 일반적인 아키텍처 패턴 중 하나가 되었기 때문에 Spring 개발 커뮤니티는 우리에게 Spring Cloud를 제공합니다. Spring Cloud 프레임워크를 사용하면 프라이빗 또는 퍼블릭 클라우드에 마이크로서비스를 간단하게 운영하고 배포할 수 있습니다. Spring Cloud는 공통 프레임워크에서 여러 인기 있는 클라우드 관리 마이크로서비스 프레임워크를 래핑합니다. 코드에 주석을 추가하는 것만큼 쉽게 이러한 기술을 사용하고 배포할 수 있습니다. 다음에서 Spring Cloud 내의 다양한 구성 요소를 다룹니다.장.

## 1.3 무엇을 만들고 있습니까?

이 책은 Spring Boot, Spring Cloud 및 기타 유용하고 현대적인 기술을 사용하여 완전한 마이크로서비스 아키텍처를 만드는 방법에 대한 단계별 가이드를 제공합니다. 그림 1.4는 이 책 전체에서 사용할 서비스 및 기술 통합의 일부에 대한 높은 수준의 개요를 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F04_Huaylupo.png)

그림 1.4 이 책에서 사용할 서비스와 기술의 개괄적인 개요

그림 1.4는 우리가 만들 마이크로서비스 아키텍처에서 조직의 정보를 업데이트하고 검색하기 위한 클라이언트 요청을 설명합니다. 요청을 시작하려면 클라이언트가 먼저 Keycloak으로 인증하여 액세스 토큰을 받아야 합니다. 토큰을 받으면 클라이언트는 Spring Cloud API Gateway에 요청합니다. API Gateway 서비스는 전체 아키텍처의 진입점입니다. 이 서비스는 Eureka 서비스 검색과 통신하여 조직 및 라이선스 서비스의 위치를 ​​검색한 다음 특정 마이크로 서비스를 호출합니다.

요청이 서비스에 도착하면 Keycloak에 대한 액세스 토큰의 유효성을 검사하여 사용자에게 프로세스를 계속할 수 있는 권한이 있는지 확인합니다. 유효성이 검사되면 서비스는 조직 데이터베이스에서 해당 정보를 업데이트 및 검색하여 HTTP 응답으로 클라이언트에 다시 보냅니다. 대체 경로로 조직 정보가 업데이트되면 조직 서비스가 Kafka 주제에 메시지를 추가하여 라이선스 서비스가 변경 사항을 인식할 수 있도록 합니다.

메시지가 라이선스 서비스에 도착하면 Redis는 특정 정보를 Redis의 메모리 내 데이터베이스에 저장합니다. 이 프로세스 전반에 걸쳐 아키텍처는 Zipkin, Elasticsearch 및 Logstash의 분산 추적을 사용하여 로그를 관리 및 표시하고 Spring Boot Actuator, Prometheus 및 Grafana를 사용하여 애플리케이션 메트릭을 노출 및 표시합니다.

앞으로 나아가면서 Spring Boot, Spring Cloud, Elasticsearch, Logstash, Kibana, Prometheus, Grafana 및 Kafka와 같은 주제를 보게 될 것입니다. 이 모든 기술이 복잡하게 들릴 수 있지만 책을 진행하면서 그림 1.4의 다이어그램을 구성하는 다양한 구성 요소를 만들고 통합하는 방법을 볼 것입니다.

## 1.4 이 책의 내용은 무엇입니까?

기본 정의에서 마이크로서비스 아키텍처를 생성하기 위한 보다 복잡한 구현에 이르기까지 모든 것을 다룹니다.

### 1.4.1 이 책에서 배울 내용

이 책은 회사에서 운영하는 프라이빗 클라우드나 Amazon, Google, Azure와 같은 퍼블릭 클라우드에 로컬로 배포할 수 있는 Spring Boot 및 Spring Cloud와 같은 다양한 Spring 프로젝트를 사용하여 마이크로 서비스 기반 애플리케이션을 구축하는 방법에 관한 것입니다. 이 책에서는 다음과 같은 주제를 다룹니다.

- 마이크로서비스란 무엇이며, 마이크로서비스 기반 애플리케이션을 구축하는 데 필요한 모범 사례 및 설계 고려 사항

- 마이크로서비스 기반 애플리케이션을 구축하면 안 되는 경우

- Spring Boot 프레임워크를 사용하여 마이크로서비스를 구축하는 방법

- 마이크로서비스 애플리케이션, 특히 클라우드 기반 애플리케이션을 지원하는 핵심 운영 패턴

- Docker는 무엇이며 마이크로 서비스 기반 애플리케이션과 통합하는 방법

- Spring Cloud를 사용하여 이 장의 뒷부분에서 설명하는 운영 패턴을 구현하는 방법

- 모니터링 도구에서 애플리케이션 메트릭을 생성하고 시각화하는 방법

- Zipkin 및 Sleuth로 분산 추적을 달성하는 방법

- ELK Stack으로 애플리케이션 로그를 관리하는 방법

- 학습한 내용을 활용하여 서비스를 로컬, 내부적으로 관리되는 프라이빗 클라우드 또는 퍼블릭 클라우드 공급자에 배포하는 데 사용할 수 있는 배포 파이프라인을 구축하는 방법

이 책을 다 읽을 때쯤이면 Spring Boot 마이크로서비스를 구축하고 배포하는 데 필요한 지식을 갖게 될 것입니다. 또한 마이크로서비스를 운영하는 데 필요한 주요 설계 결정을 이해하게 됩니다. 서비스 구성 관리, 서비스 검색, 메시징, 로깅 및 추적, 보안이 모두 어떻게 결합되어 강력한 마이크로서비스 환경을 제공하는지 알게 될 것입니다. 마지막으로 다양한 방법을 사용하여 마이크로서비스를 배포하는 방법을 확인할 수 있습니다.기술.

### 1.4.2 이 책이 왜 당신과 관련이 있습니까?

당신이 이 지점에 도달했다면, 당신이

- Java 개발자이거나 Java에 대한 이해도가 높으신 분

- Spring을 알고 있거나

- 마이크로 서비스 기반 애플리케이션을 구축하는 방법을 배우는 데 관심이 있습니다.

- 마이크로서비스를 사용하여 클라우드 기반 애플리케이션을 구축하는 방법에 관심이 있습니다.

- Java 및 Spring이 마이크로서비스 기반 애플리케이션 구축에 적합한 기술인지 알고 싶습니다.

- 마이크로서비스 아키텍처를 달성하기 위한 최첨단 기술이 무엇인지 알고 싶습니다.

- 마이크로서비스 기반 애플리케이션을 클라우드에 배포하는 과정에 관심이 있습니다.

이 책은 자바에서 마이크로서비스 아키텍처를 구현하는 방법에 대한 자세한 가이드를 제공합니다. Spring Boot 및 Spring Cloud와 같은 다양한 Spring 프로젝트의 최신 버전을 사용하여 이 아키텍처를 구현하는 방법에 대한 프로그래밍 방식의 가이드를 제공하기 위해 설명 및 시각적 정보와 많은 실습 코드 예제를 제공합니다.

또한 이 책에서는 실제 애플리케이션 개발 환경을 시뮬레이션하는 이러한 유형의 아키텍처와 함께 사용되는 마이크로서비스 패턴, 모범 사례 및 인프라 기술에 대한 소개를 제공합니다. 잠시 기어를 변경하고 다음을 사용하여 간단한 마이크로서비스를 구축하는 과정을 살펴보겠습니다.봄 신병.

## 1.5 클라우드 및 마이크로서비스 기반 애플리케이션

이 섹션에서는 Spring Boot를 사용하여 마이크로 서비스를 생성하는 방법을 살펴보고 클라우드가 마이크로 서비스 기반 애플리케이션과 관련이 있는 이유를 배웁니다.

### 1.5.1 스프링 부트로 마이크로서비스 구축하기

이 섹션에서는 마이크로서비스를 만드는 데 사용할 많은 코드에 대한 자세한 설명을 제공하지 않지만 Spring Boot를 사용하는 것이 얼마나 쉬운지 보여주기 위해 서비스를 만드는 방법에 대한 간략한 소개일 뿐입니다. 이를 위해 GET HTTP 동사를 사용하는 하나의 메인 엔드포인트가 있는 "Hello World"에 대한 간단한 REST 서비스를 만들 것입니다. 이 서비스 엔드포인트는 요청 매개변수 및 URL 매개변수( 경로 변수 라고도 함)를 수신 합니다.). 그림 1.5는 REST 서비스가 수행할 작업과 Spring Boot 마이크로서비스가 사용자 요청을 처리하는 방법의 일반적인 흐름을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F05_Huaylupo.png)

그림 1.5 Spring Boot는 일반적인 REST 마이크로 서비스 작업(비즈니스 로직으로 라우팅, URL에서 HTTP 매개변수 구문 분석, Java 객체와 JSON 매핑)을 추상화하고 개발자가 서비스의 비즈니스 로직에 집중할 수 있도록 합니다. 이 그림은 컨트롤러에 매개변수를 전달하는 세 가지 다른 방법을 보여줍니다.

이 예제는 프로덕션 수준의 마이크로 서비스를 구축하는 방법에 대한 완전하거나 예시적인 것이 아니지만 작성하는 데 필요한 코드가 적기 때문에 일시 정지합니다. 프로젝트 빌드 파일을 설정하는 방법이나 코드의 세부 사항은 2장까지 다루지 않을 것입니다. Maven pom.xml 파일과 실제 코드를 보고 싶다면 1장에서 찾을 수 있습니다.

> 참고 https://github.com/ihuaylupo/manning-smia/tree/master/chapter1 의 GitHub 리포지토리에서 1장의 모든 소스 코드를 검색할 수 있습니다 .

이 예에서는 이라는 단일 Java 클래스가 있습니다. Application, com/huaylupo/spmia/ch01/SimpleApplication/Application.java 클래스 파일에서 찾을 수 있습니다. 이 클래스를 사용하여 라는 REST 끝점을 노출합니다 /hello. 다음 목록은 Application클래스에 대한 코드를 보여줍니다 .

Listing 1.1 Spring Boot를 사용한 Hello World: (매우) 간단한 Spring 마이크로서비스

```java
@SpringBootApplication ❶
@RestController ❷
@RequestMapping(value="hello") ❸
public class Application {

   public static void main(String[] args) {
      SpringApplication.run(Application.class, args);
   }

   @GetMapping(value="/{firstName}") ❹
   public String helloGET( 
     @PathVariable("firstName") String firstName, ❺
     @RequestParam("lastName") String lastName) { ❺
     return String.format(
            "{\"message\":\"Hello %s %s\"}", ❻
               firstName, lastName);
   }
}

class HelloRequest{ ❼

   private String firstName;
   private String lastName;

   public String getFirstName() {       
     return firstName;
   }
   public void setFirstName(String firstName) {
     this.firstName = firstName;
   }
   public String getLastName() {
     return lastName;
   }
   public void setLastName(String lastName) {
     this.lastName = lastName;
   }
}
```
❶ 이 클래스가 Spring Boot 서비스의 진입점임을 Spring Boot에 알립니다.

❷ 이 클래스의 코드를 Spring RestController로 노출하도록 Spring Boot에 지시합니다.

❸ 이 애플리케이션에 노출된 모든 URL 앞에 /hello 접두어를 붙입니다.

❹ 엔드포인트를 firstName(@PathVariable을 통해)과 lastName(@RequestParam을 통해)에 두 개의 매개변수를 사용하는 GET 기반 REST로 노출

❺ firstName 및 lastName 매개변수를 hello 함수에 전달된 두 변수에 매핑합니다.

❻ 수동으로 빌드한 간단한 JSON 문자열을 반환합니다(2장에서는 JSON을 생성하지 않습니다).

❼ 사용자가 보낸 JSON 구조의 필드를 포함합니다.

목록 1.1에서는 기본적으로 두 개의 매개변수(firstName 그리고 lastName) URL: 경로 변수(@PathVariable) 및 다른 하나를 요청 매개변수( @RequestParam)로 사용합니다. 엔드포인트는 메시지가 포함된 페이로드가 있는 간단한 JSON 문자열을 반환합니다 "Hello firstName lastName". /hello/illary?lastName=huaylupo서비스 에서 GET 끝점을 호출하려면 반환 호출은 다음과 같습니다.
```json
{"message":"Hello illary huaylupo"}
```

Spring Boot 애플리케이션을 시작하겠습니다. 이를 위해 명령줄에서 다음 명령을 실행해 보겠습니다. 이 Maven 명령은 pom.xml 파일에 정의된 Spring Boot 플러그인을 사용하여 임베디드 Tomcat 서버를 사용하여 애플리케이션을 시작합니다. mvn spring-boot:run명령 을 실행하면 모든 것이 올바르게 시작되면 명령줄 창에 그림 1.6에 표시된 내용이 표시되어야 합니다.
```sh
mvn spring-boot:run
```

> 참고 명령줄에서 명령을 실행하는 경우 루트 디렉터리에 있는지 확인하십시오. 루트 디렉토리는 pom.xml 파일을 포함하는 디렉토리입니다. 그렇지 않으면 현재 프로젝트와 플러그인 그룹에서 'spring-boot' 접두사에 대한 플러그인을 찾을 수 없다는 오류가 발생합니다.

#### Java 대 Groovy 및 Maven 대 Gradle

Spring Boot 프레임워크는 Java와 Groovy 프로그래밍 언어를 모두 지원합니다. Spring Boot는 Maven 및 Gradle 빌드 도구도 모두 지원합니다. Gradle은 Maven과 같은 XML 파일 대신 프로젝트 구성을 선언하기 위해 Groovy 기반 DSL(도메인별 언어)을 도입합니다. Gradle이 강력하고 유연하며 최고 등급이지만 Maven은 여전히 ​​Java 개발자 커뮤니티에서 사용됩니다. 따라서 이 책은 관리하기 쉽고 자료에 집중할 수 있도록 Maven의 예제만 포함하고 있으며 가능한 한 많은 청중에게 다가가기 위한 것입니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F06_Huaylupo.png)

그림 1.6 Spring Boot 서비스는 콘솔을 통해 서비스 포트와 통신합니다.

서비스를 실행하려면 브라우저 기반 REST 도구를 사용해야 합니다. REST 기반 서비스를 호출하기 위한 많은 도구(그래픽 및 명령줄)를 찾을 수 있습니다. 이 책에서는 Postman( https://www.getpostman.com/ )을 사용합니다. 그림 1.7과 1.8은 서비스에서 반환된 결과와 함께 끝점에 대한 두 가지 다른 Postman 호출을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F07_Huaylupo.png)

그림 1.7 GET /hello엔드포인트 의 응답은 JSON 페이로드로 표시된 요청한 데이터를 보여줍니다.

그림 1.8은 POST HTTP 동사를 사용하여 호출하는 방법의 간단한 예를 보여줍니다. 이것은 단지 시연을 위한 것임을 언급하는 것이 중요합니다. 다음 장에서는 서비스에서 새 레코드를 생성할 때 POST 방식이 선호됨을 알 수 있습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F08_Huaylupo.png)

그림 1.8 POST /hello끝점의 응답은 요청과 JSON 페이로드로 표시된 응답 데이터를 보여줍니다.

이 간단한 예제 코드는 Spring Boot의 모든 기능이나 서비스를 생성하는 모범 사례를 보여주지 않습니다. 그러나 몇 줄의 코드로 Java에서 URL 및 매개변수의 경로 매핑을 사용하여 전체 HTTP JSON REST 기반 서비스를 작성할 수 있음을 보여줍니다. Java는 강력한 언어이지만 다른 언어에 비해 말이 많다는 평판을 얻었습니다. 그러나 Spring을 사용하면 몇 줄의 코드로 많은 것을 수행할 수 있습니다. 다음으로 마이크로서비스 접근 방식이 구축에 적합한 이유와 시기를 살펴보겠습니다.응용 프로그램.

### 1.5.2 클라우드 컴퓨팅이란 정확히 무엇입니까?

클라우드 컴퓨팅은 유연하고 안전하며 사용하기 쉬운 환경을 제공하기 위해 인터넷을 통해 컴퓨팅 및 가상화된 IT 서비스(데이터베이스, 네트워킹, 소프트웨어, 서버, 분석 등)를 제공하는 것입니다. 클라우드 컴퓨팅은 무엇보다도 낮은 초기 투자, 사용 및 유지 관리 용이성, 확장성과 같은 회사 내부 관리에 상당한 이점을 제공합니다.

클라우드 컴퓨팅 모델을 통해 사용자는 이러한 모델이 제공하는 정보 및 서비스에 대한 제어 수준을 선택할 수 있습니다. 이러한 모델은 약어로 알려져 있으며 일반적으로 XaaS(서비스로서의 모든 것을 의미하는 약어)라고 합니다. 다음은 가장 일반적인 클라우드 컴퓨팅 모델을 나열합니다. 그림 1.9는 이러한 모델 간의 차이점을 보여줍니다.

- 서비스로서의 인프라 (IaaS) — 공급업체는 서버, 스토리지 및 네트워크와 같은 컴퓨팅 리소스에 액세스할 수 있는 인프라를 제공합니다. 이 모델에서 사용자는 인프라의 유지 관리 및 애플리케이션의 확장성과 관련된 모든 것을 책임집니다.

IaaS 플랫폼에는 AWS(EC2), Azure Virtual Machines, Google Compute Engine 및 Kubernetes가 포함됩니다.

- 서비스로서의 컨테이너 (CaaS) — IaaS와 PaaS의 중간 모델로 컨테이너 기반 가상화의 한 형태를 말합니다. 개발자가 서비스가 배포되는 가상 머신을 관리하는 IaaS 모델과 달리 CaaS를 사용하면 마이크로서비스를 경량의 휴대용 가상 컨테이너(예: Docker)에서 클라우드 공급자에게 배포합니다. 클라우드 공급자는 컨테이너가 실행 중인 가상 서버와 컨테이너 구축, 배포, 모니터링 및 확장을 위한 공급자의 포괄적인 도구를 실행합니다.

CaaS 플랫폼에는 Google Container Engine이 포함됩니다. (GKE) 및 Amazon의 Elastic Container Service(ECS). 11장에서는 구축한 마이크로서비스를 Amazon ECS에 배포하는 방법을 살펴봅니다.

- 서비스로서의 플랫폼 (PaaS) —이 모델은 사용자가 애플리케이션의 개발, 실행 및 유지 관리에 집중할 수 있는 플랫폼 및 환경을 제공합니다. 애플리케이션은 공급업체에서 제공하는 도구(예: 운영 체제, 데이터베이스 관리 시스템, 기술 지원, 스토리지, 호스팅, 네트워크 등)를 사용하여 생성할 수 있습니다. 사용자는 물리적 인프라에 투자하거나 관리하는 데 시간을 할애할 필요가 없으므로 애플리케이션 개발에만 전념할 수 있습니다.

PaaS 플랫폼에는 Google App Engine, Cloud Foundry, Heroku 및 AWS Elastic Beanstalk가 있습니다.

- 서비스로서의 기능 (FaaS) — 서버리스 아키텍처라고도 하며 이름에도 불구하고 이 아키텍처는 서버 없이 특정 코드를 실행하는 것을 의미하지 않습니다. 이것이 의미하는 바는 공급업체가 필요한 모든 서버를 제공하는 클라우드에서 기능을 실행하는 방법입니다. 서버리스 아키텍처를 사용하면 확장, 프로비저닝 및 서버 관리에 대해 걱정할 필요 없이 서비스 개발에만 집중할 수 있습니다. 대신 관리 인프라를 처리하지 않고 기능 업로드에만 집중할 수 있습니다.

FaaS 플랫폼에는 AWS(Lambda), Google Cloud Function 및 Azure Function이 포함됩니다.

- 서비스로서의 소프트웨어 (SaaS) - 주문형 소프트웨어라고도 하는 이 모델을 사용하면 사용자가 특정 응용 프로그램을 배포하거나 유지 관리할 필요 없이 사용할 수 있습니다. 대부분의 경우 웹 브라우저를 통해 액세스합니다. 애플리케이션, 데이터, 운영 체제, 가상화, 서버, 스토리지, 네트워크 등 모든 것은 서비스 제공자가 관리합니다. 사용자는 서비스를 고용하고 소프트웨어를 사용합니다.

SaaS 플랫폼에는 Salesforce, SAP 및 Google이 포함됩니다. 

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F09_Huaylupo.png)

그림 1.9 다양한 클라우드 컴퓨팅 모델은 사용자 관리 또는 클라우드 공급업체 중 누가 무엇을 담당하는지에 따라 결정됩니다.

참고 주의하지 않으면 코드가 공급업체별 런타임 엔진에 배포되기 때문에 FaaS 기반 플랫폼이 코드를 클라우드 공급업체 플랫폼에 잠글 수 있습니다. FaaS 기반 모델을 사용하면 일반 프로그래밍 언어(Java, Python, JavaScript 등)를 사용하여 서비스를 작성할 수 있지만 여전히 기본 공급업체의 API 및 기능이 구현될 런타임 엔진에 자신을 묶고 있습니다. 에 배치되었습니다.

### 1.5.3 왜 클라우드와 마이크로서비스인가?

마이크로 서비스 아키텍처의 핵심 개념 중 하나는 각 서비스가 자체적으로 분리되고 독립적인 아티팩트로 패키징되고 배포된다는 것입니다. 서비스 인스턴스는 신속하게 가져와야 하며 각각은 서로 구별할 수 없어야 합니다. 마이크로 서비스를 작성할 때 조만간 서비스를 다음 중 하나에 배포할지 여부를 결정해야 합니다.

- 물리적 서버—마이크로 서비스를 구축하고 물리적 시스템에 배포할 수 있지만 물리적 서버가 제한되어 있기 때문에 이를 수행하는 조직은 거의 없습니다. 물리적 서버의 용량을 빠르게 늘릴 수 없으며 여러 물리적 서버에 걸쳐 수평적으로 마이크로서비스를 확장하는 데 막대한 비용이 소요될 수 있습니다.

- 가상 머신 이미지—마이크로서비스의 주요 이점 중 하나는 확장성 및 서비스 장애 이벤트에 대한 응답으로 인스턴스를 신속하게 시작 및 종료할 수 있다는 것입니다. 가상 머신 (VM)은 주요 클라우드 제공업체의 심장이자 영혼입니다.

- 가상 컨테이너—가상 컨테이너는 VM 이미지에 마이크로서비스를 배포하는 자연스러운 확장입니다. 많은 개발자는 전체 VM에 서비스를 배포하는 대신 클라우드에 Docker 컨테이너(또는 동등한 컨테이너 기술)로 서비스를 배포합니다. 가상 컨테이너는 VM 내에서 실행되며 가상 컨테이너를 사용하여 단일 VM을 동일한 이미지를 공유하는 일련의 자체 포함된 프로세스로 분리할 수 있습니다. 마이크로 서비스를 패키징할 수 있으며, 그런 다음 서비스의 여러 인스턴스를 IaaS 프라이빗 또는 퍼블릭 클라우드에서 빠르게 배포하고 시작할 수 있습니다.

클라우드 기반 마이크로서비스의 장점은 탄력성 개념을 중심으로 합니다.. 클라우드 서비스 공급자를 사용하면 몇 분 만에 새 VM과 컨테이너를 빠르게 가동할 수 있습니다. 서비스에 대한 용량 요구 사항이 감소하는 경우 추가 비용을 피하기 위해 컨테이너를 스핀다운할 수 있습니다. 클라우드 공급자를 사용하여 마이크로서비스를 배포하면 애플리케이션에 대해 훨씬 더 많은 수평 확장성(더 많은 서버 및 서비스 인스턴스 추가)을 얻을 수 있습니다.

서버 탄력성은 또한 애플리케이션이 더 탄력적일 수 있음을 의미합니다. 마이크로 서비스 중 하나에 문제가 있고 장애 조치가 발생하는 경우 새 서비스 인스턴스를 가동하면 개발 팀이 문제를 정상적으로 해결할 수 있을 만큼 충분히 오랫동안 애플리케이션을 유지할 수 있습니다.

이 책에서는 모든 마이크로서비스와 해당 서비스 인프라가 Docker 컨테이너를 사용하여 CaaS 기반 클라우드 제공업체에 배포됩니다. 이것은 마이크로 서비스에 대한 일반적인 배포 토폴로지입니다. CaaS 클라우드 공급자의 가장 일반적인 특성은 다음과 같습니다.

- 간소화된 인프라 관리 — CaaS 클라우드 제공업체를 통해 서비스를 더 잘 제어할 수 있습니다. 간단한 API 호출로 새로운 서비스를 시작하고 중지할 수 있습니다.

- 대규모 수평 확장성 — CaaS 클라우드 공급자를 통해 하나 이상의 서비스 인스턴스를 빠르고 간결하게 시작할 수 있습니다. 이 기능은 서비스를 신속하게 확장하고 오작동하거나 장애가 있는 서버를 우회할 수 있음을 의미합니다.

- 지리적 분산을 통한 높은 중복성 — 필요에 따라 CaaS 제공업체에는 여러 데이터 센터가 있습니다. CaaS 클라우드 공급자를 사용하여 마이크로서비스를 배포하면 데이터 센터에서 클러스터를 사용하는 것 이상으로 더 높은 수준의 중복성을 얻을 수 있습니다.

> PaaS 기반 마이크로서비스가 아닌 이유는 무엇입니까?

이 장의 앞부분에서 IaaS, CaaS, PaaS, FaaS, SaaS 등 5가지 유형의 클라우드 플랫폼에 대해 논의했습니다. SaaS). 이 책은 특히 CaaS 접근 방식을 사용하여 마이크로서비스를 구축하는 데 중점을 둡니다. 특정 클라우드 제공업체가 마이크로서비스의 배포 인프라를 추상화할 수 있도록 해주지만 이 책에서는 공급업체에 독립적인 상태를 유지하고 애플리케이션(서버 포함)의 모든 부분을 배포하는 방법을 알려줍니다.

예를 들어 Cloud Foundry, AWS Elastic Beanstalk, Google App Engine 및 Heroku는 기본 애플리케이션 컨테이너에 대해 알지 않고도 서비스를 배포할 수 있는 기능을 제공합니다. 이들은 웹 인터페이스 및 CLI를 제공하여 애플리케이션을 WAR 또는 JAR 파일로 배포할 수 있도록 합니다. 애플리케이션 서버와 해당 Java 컨테이너를 설정하고 조정하는 작업이 추상화됩니다. 이것이 편리하긴 하지만 각 클라우드 공급자의 플랫폼은 개별 PaaS 솔루션과 관련된 고유한 특성이 있습니다.

이 책에서 구축한 서비스는 Docker 컨테이너로 패키징됩니다. 주된 이유는 Docker가 모든 주요 클라우드 제공업체에 배포 가능하기 때문입니다. 이후 장에서 Docker가 무엇인지 알아보고 Docker를 통합하여 사용되는 모든 서비스와 인프라를 실행하는 방법을 배웁니다.

## 1.6 마이크로서비스는 코드를 작성하는 것 이상입니다.

개별 마이크로서비스 구축에 대한 개념은 이해하기 쉽지만, 강력한 마이크로서비스 애플리케이션(특히 클라우드에서 실행할 때)을 실행 및 지원하는 데 단순히 서비스에 대한 코드를 작성하는 것 이상이 포함됩니다. 그림 1.10은 마이크로서비스를 작성하거나 구축할 때 고려해야 할 몇 가지 지침을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F10_Huaylupo.png)

그림 1.10 마이크로서비스는 비즈니스 로직 그 이상입니다. 서비스를 실행할 환경과 서비스가 확장되고 복원되는 방식에 대해 생각해야 합니다.

강력한 서비스 작성에는 여러 주제를 고려하는 작업이 포함됩니다. 그림 1.10에 표시된 항목을 더 자세히 살펴보겠습니다.

- 적정 규모 — 마이크로 서비스가 너무 많은 책임을 지게 하지 않도록 마이크로 서비스의 규모를 적절하게 조정하는 방법입니다. 적절한 크기의 서비스를 사용하면 애플리케이션을 신속하게 변경할 수 있고 전체 애플리케이션에 대한 중단의 전반적인 위험을 줄일 수 있습니다.

- 위치 투명 - 서비스 호출의 물리적 세부 정보를 관리하는 방법입니다. 마이크로 서비스 애플리케이션에 있을 때 여러 서비스 인스턴스가 빠르게 시작 및 종료될 수 있습니다.

- 탄력성 — 실패한 서비스를 우회하고 "fail-fast" 접근 방식을 취하도록 하여 마이크로서비스 소비자와 애플리케이션의 전반적인 무결성을 보호하는 방법.

- 반복 가능 — 가져온 서비스의 모든 새 인스턴스가 프로덕션의 다른 모든 서비스 인스턴스와 동일한 구성 및 코드베이스를 갖도록 보장하는 방법입니다.

- 확장성 — 서비스 간의 직접적인 종속성을 최소화하고 마이크로서비스를 정상적으로 확장할 수 있도록 하는 통신을 설정하는 방법입니다.

이 책은 패턴 기반 접근 방식을 취하여 이러한 항목을 더 자세히 살펴봅니다. 패턴 기반 접근 방식을 통해 다양한 기술 구현에서 사용할 수 있는 일반적인 디자인을 살펴보겠습니다. 이 책에서 사용할 패턴을 구현하기 위해 Spring Boot와 Spring Cloud를 사용하기로 선택했지만 여기에 제시된 개념을 다른 기술 플랫폼과 함께 사용하는 데 방해가 되는 것은 없습니다. 특히 다음 마이크로 서비스 패턴을 다룹니다.

- 코어 개발 패턴
- 라우팅 패턴
- 클라이언트 복원 패턴
- 보안 패턴
- 로깅 및 추적 패턴
- 애플리케이션 메트릭 패턴
- 빌드 및 배포 패턴

마이크로 서비스를 만드는 방법에 대한 공식적인 정의가 없다는 것을 이해하는 것이 중요합니다. 다음 섹션에서는 빌드하는 동안 고려해야 하는 일반적인 측면 목록을 볼 수 있습니다.

## 1.7 핵심 마이크로서비스 개발 패턴

핵심 마이크로서비스 개발 패턴은 마이크로서비스 구축의 기본 사항을 다룹니다. 그림 1.11은 기본 서비스 디자인과 관련하여 다룰 주제를 강조 표시합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F11_Huaylupo.png)

그림 1.11 마이크로서비스를 설계할 때 서비스가 어떻게 소비되고 통신될 것인지에 대해 생각해야 합니다.

다음 패턴(그림 1.11 참조)은 마이크로서비스 구축의 기본 사항을 보여줍니다.

- **서비스 규모** —각 마이크로 서비스가 적절한 수준의 책임을 갖도록 비즈니스 도메인을 마이크로 서비스로 분해하는 방법은 무엇입니까? 서로 다른 비즈니스 문제 도메인에 겹치는 책임으로 서비스를 너무 거칠게 만들면 시간이 지남에 따라 서비스를 유지 관리하고 변경하기가 어렵습니다. 서비스를 너무 세분화하면 애플리케이션의 전반적인 복잡성이 증가하고 데이터 저장소에 액세스하는 데 필요한 논리 외에는 논리가 없는 "멍청한" 데이터 추상화 계층으로 서비스가 바뀝니다. 서비스 세분성은 3장에서 다룹니다.

- **통신 프로토콜** —개발자는 귀하의 서비스와 어떻게 통신합니까? 첫 번째 단계는 동기 또는 비동기 프로토콜을 원하는지 정의하는 것입니다. 동기식의 경우 가장 일반적인 통신은 XML, JSON 또는 Thrift와 같은 바이너리 프로토콜을 사용하여 마이크로서비스로 데이터를 주고받는 HTTP 기반 REST입니다. 비동기식의 경우 가장 인기 있는 프로토콜은 RabbitMQ, Apache Kafka 및 Amazon Simple Queue Service와 같은 메시지 브로커와 함께 일대일(대기열) 또는 일대다(주제)를 사용하는 AMQP입니다. 나중 장에서 통신 프로토콜에 대해 배울 것입니다.

- 인터페이스 디자인 —개발자가 서비스를 호출하는 데 사용할 실제 서비스 인터페이스를 디자인하는 가장 좋은 방법은 무엇입니까? 서비스를 어떻게 구성합니까? 모범 사례는 무엇입니까? 모범 사례와 인터페이스 디자인은 다음 장에서 다룹니다.

- 서비스 구성 관리 —마이크로서비스가 클라우드의 서로 다른 환경 간에 이동할 수 있도록 구성을 어떻게 관리합니까? 이는 5장에서 볼 수 있는 외부 구성 및 프로필로 관리할 수 있습니다.

- 서비스 간 이벤트 처리 — 서비스 간의 하드코딩된 종속성을 최소화하고 애플리케이션의 복원력을 높이기 위해 이벤트를 사용하여 마이크로 서비스를 어떻게 분리합니까? 10장에서 Spring Cloud Stream과 함께 이벤트 중심 아키텍처를 사용할 것입니다.

# 1.8 마이크로서비스 라우팅 패턴

마이크로 서비스 라우팅 패턴은 마이크로 서비스를 사용하려는 클라이언트 애플리케이션이 서비스의 위치를 ​​발견하고 서비스로 라우팅되는 방법을 처리합니다. 클라우드 기반 애플리케이션에서는 수백 개의 마이크로서비스 인스턴스를 실행할 수 있습니다. 보안 및 콘텐츠 정책을 시행하려면 해당 서비스의 물리적 IP 주소를 추상화하고 서비스 호출에 대한 단일 진입점이 있어야 합니다. .

- 서비스 검색 — 서비스 검색 및 주요 기능인 서비스 레지스트리를 사용하면 마이크로서비스를 검색 가능하게 만들 수 있으므로 서비스 위치를 애플리케이션에 하드코딩하지 않고도 클라이언트 애플리케이션이 마이크로서비스를 찾을 수 있습니다. 6장에서 이에 대해 설명합니다. 서비스 검색은 클라이언트 대면 서비스가 아니라 내부 서비스임을 기억하십시오.

이 책에서는 Netflix Eureka Service Discovery를 사용하지만 etcd, Consul, Apache Zookeeper와 같은 다른 서비스 레지스트리가 있습니다. 또한 일부 시스템에는 명시적 서비스 레지스트리가 없습니다. 대신 서비스 mesh로 알려진 서비스 간 통신 인프라를 사용합니다 .

- 서비스 라우팅 — API 게이트웨이를 사용하면 보안 정책과 라우팅 규칙이 마이크로서비스 애플리케이션의 여러 서비스 및 서비스 인스턴스에 균일하게 적용되도록 모든 서비스에 대한 단일 진입점을 제공할 수 있습니다. 8장에서 Spring Cloud API Gateway를 사용을 설명합니다.

그림 1.12는 서비스 검색과 서비스 라우팅이 이들 사이에 하드코딩된 이벤트 시퀀스를 갖는 것처럼 보이는 방법을 보여줍니다(먼저 서비스 라우팅과 서비스 검색이 옴). 그러나 두 패턴은 서로 의존하지 않습니다. 예를 들어 서비스 라우팅 없이 서비스 검색을 구현할 수 있고 서비스 검색 없이 서비스 라우팅을 구현할 수 있습니다(구현이 더 많은 경우에도어려운).

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F12_Huaylupo.png)

그림 1.12 서비스 검색 및 서비스 라우팅은 모든 대규모 마이크로서비스 애플리케이션의 핵심 부분입니다.

## 1.9 마이크로서비스 클라이언트 복원력

마이크로서비스 아키텍처는 고도로 분산되어 있으므로 단일 서비스(또는 서비스 인스턴스)의 문제가 서비스 소비자에게 연쇄적으로 발생하는 것을 방지하는 방법에 매우 민감해야 합니다. 이를 위해 4가지 클라이언트 복원 패턴을 다룹니다.

- 클라이언트 측 부하 분산 — 마이크로 서비스의 여러 인스턴스에 대한 호출이 해당 마이크로 서비스의 모든 상태 인스턴스에 로드 밸런싱되도록 서비스에서 서비스 인스턴스의 위치를 ​​캐시하는 방법.

- 회로 차단기 패턴 — 클라이언트가 실패하거나 성능 문제를 겪고 있는 서비스를 계속 호출하지 못하도록 하는 방법입니다. 서비스가 느리게 실행되면 이를 호출하는 클라이언트의 리소스를 소비합니다. 호출 클라이언트가 신속하게 응답하고 적절한 조치를 취할 수 있도록 이러한 마이크로서비스 호출이 빠르게 실패하기를 원합니다.

- 폴백 패턴 - 서비스 호출이 실패할 때 서비스 클라이언트가 호출되는 마이크로서비스가 아닌 다른 수단을 통해 작업을 수행할 수 있도록 하는 "플러그인" 메커니즘을 제공하는 방법입니다.

- 격벽 패턴—마이크로서비스 애플리케이션은 여러 분산 리소스를 사용하여 작업을 수행합니다. 이 패턴은 한 서비스 호출의 오작동이 나머지 애플리케이션에 부정적인 영향을 미치지 않도록 이러한 호출을 구획화하는 방법을 나타냅니다.

그림 1.13은 이러한 패턴이 서비스가 오작동할 때 영향을 받는 것으로부터 서비스 소비자를 보호하는 방법을 보여줍니다. 이 주제는 다음에서 다룹니다.7장.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F13_Huaylupo.png)

그림 1.13 마이크로서비스를 사용하면 제대로 작동하지 않는 서비스로부터 서비스 호출자를 보호해야 합니다. 느리거나 다운된 서비스는 즉각적인 서비스를 넘어 중단을 일으킬 수 있음을 기억하십시오.

## 1.10 마이크로서비스 보안 패턴

마이크로서비스가 대중에게 공개되지 않도록 하려면 적절한 자격 증명이 있는 승인된 요청만 서비스를 호출할 수 있도록 아키텍처에 다음 보안 패턴을 적용하는 것이 중요합니다. 그림 1.14는 이러한 세 가지 패턴을 구현하여 사용자를 보호할 수 있는 인증 서비스를 구축하는 방법을 보여줍니다.

- 인증 — 서비스를 호출하는 서비스 클라이언트를 결정하는 방법은 그들이 말하는 사람입니다.

- 권한 부여 — 마이크로 서비스를 호출하는 서비스 클라이언트가 수행하려는 작업을 수행할 수 있는지 여부를 결정하는 방법.

- 자격 증명 관리 및 전파 — 서비스 클라이언트가 트랜잭션과 관련된 서비스 호출에 대한 자격 증명을 지속적으로 제시하지 않도록 하는 방법. 이를 달성하기 위해 OAuth2 및 JSON 웹 토큰과 같은 토큰 기반 보안 표준을 사용하는 방법을 살펴보겠습니다. 토큰을 사용하여 사용자를 인증하고 권한을 부여하기 위해 서비스 호출에서 서비스 호출로 전달할 수 있는 액세스 토큰을 얻습니다.

OAuth 2.0이란 무엇입니까?

OAuth2는 사용자가 타사 인증 서비스를 통해 자신을 인증할 수 있도록 하는 토큰 기반 보안 프레임워크입니다. 사용자가 성공적으로 인증되면 모든 요청과 함께 보내야 하는 토큰이 제공됩니다.

OAuth2의 주요 목표는 사용자의 요청을 이행하기 위해 여러 서비스가 호출될 때 요청을 처리하는 각 서비스에 자격 증명을 제시하지 않고도 각 서비스에서 사용자를 인증할 수 있다는 것입니다. OAuth는 9장에서 다루지만 Aaron Parecki( https://www.oauth.com/ ) 의 OAuth 2.0 문서를 읽는 것이 좋습니다 .

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F14_Huaylupo.png)

그림 1.14 토큰 기반 보안 체계를 사용하면 클라이언트 자격 증명을 전달하지 않고 서비스 인증 및 권한 부여를 구현할 수 있습니다.

## 1.11 마이크로서비스 로깅 및 추적 패턴

마이크로 서비스 아키텍처의 단점은 하나의 간단한 작업이 애플리케이션 내에서 수많은 마이크로 서비스 호출을 트리거할 수 있기 때문에 문제를 디버그, 추적 및 모니터링하는 것이 훨씬 더 어렵다는 것입니다. 다음 장에서는 Spring Cloud Sleuth, Zipkin 및 ELK Stack을 사용하여 분산 추적을 구현하는 방법을 다룹니다. 이러한 이유로 분산 추적을 달성하기 위해 다음 세 가지 핵심 로깅 및 추적 패턴을 살펴보겠습니다.

- 로그 상관 관계 — 단일 사용자 트랜잭션에 대해 서비스 간에 생성된 모든 로그를 함께 묶는 방법. 이 패턴을 사용하여 트랜잭션의 모든 서비스 호출에 전달되고 각 서비스에서 생성된 로그 항목을 함께 묶는 데 사용할 수 있는 고유 식별자인 상관 관계 ID를 구현하는 방법을 살펴보겠습니다.

- 로그 집계 —이 패턴을 사용하여 마이크로서비스(및 개별 인스턴스)에서 생성된 모든 로그를 관련된 모든 서비스에 걸쳐 쿼리 가능한 단일 데이터베이스로 통합하고 서비스의 성능 특성을 이해하는 방법을 살펴봅니다. 거래.

- 마이크로서비스 추적 — 관련된 모든 서비스에서 클라이언트 트랜잭션의 흐름을 시각화하고 트랜잭션 서비스의 성능 특성을 이해하는 방법을 탐색합니다.

그림 1.15는 이러한 패턴이 어떻게 함께 들어맞는지 보여줍니다. 11장 로깅 및 추적 패턴은 에서 더 자세히 다룰 것입니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F07_Huaylupo.png)

그림 1.15 신중하게 고려된 로깅 및 추적 전략을 통해 여러 서비스에서 트랜잭션 디버깅을 관리할 수 있습니다.

## 1.12 애플리케이션 메트릭 패턴

메트릭 패턴은 애플리케이션이 메트릭을 모니터링하고 애플리케이션 내에서 가능한 실패 원인을 경고하는 방법을 다룹니다. 이 패턴은 서비스의 잠재적인 성능 문제를 방지하기 위해 메트릭 서비스가 비즈니스 관련 데이터를 가져오고(스크레이핑), 저장하고, 쿼리하는 방법을 보여줍니다. 이 패턴에는 다음 세 가지 주요 구성 요소가 포함됩니다.

- 측정 항목 — 애플리케이션의 상태에 대한 중요한 정보를 생성하는 방법과 이러한 메트릭을 노출하는 방법

- 측정 항목 서비스—애플리케이션 메트릭을 저장하고 쿼리할 수 있는 위치

- 메트릭 시각화 제품군 — 애플리케이션 및 인프라에 대한 비즈니스 관련 시간 데이터를 시각화할 수 있는 곳

그림 1.16은 마이크로서비스에 의해 생성된 메트릭이 메트릭 서비스 및 시각화 제품군에 어떻게 크게 의존하는지 보여줍니다. 그 정보를 이해하고 분석할 방법이 없다면 무한한 정보를 생성하고 보여주는 지표를 갖는 것은 쓸모가 없을 것입니다. 메트릭 서비스는 풀 또는 푸시 스타일을 사용하여 메트릭을 얻을 수 있습니다.

푸시 스타일에서 서비스 인스턴스는 애플리케이션 데이터를 보내기 위해 메트릭 서비스에 의해 노출된 서비스 API를 호출합니다.

풀 스타일을 사용하면 메트릭 서비스가 애플리케이션 데이터를 가져오기 위해 함수를 요청하거나 쿼리합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F16_Huaylupo.png)

그림 1.16 마이크로서비스에서 메트릭을 가져오거나 푸시하고 메트릭 시각화 제품군 및 경고 관리 도구를 사용하여 표시할 메트릭 서비스에 수집 및 저장합니다.

모니터링 메트릭은 마이크로 서비스 아키텍처의 필수 측면이며 이러한 종류의 아키텍처에서 모니터링 요구 사항은 높은 분포.

## 1.13 마이크로서비스 구축/배포 패턴

마이크로 서비스 아키텍처의 핵심 부분 중 하나는 마이크로 서비스의 각 인스턴스가 다른 모든 인스턴스와 동일해야 한다는 것입니다. 구성 드리프트를 허용할 수 없습니다. (배포된 후 서버에서 무언가 변경됨) 발생하는 이유는 애플리케이션이 불안정해질 수 있기 때문입니다.

이 패턴의 목표는 인프라 구성을 빌드/배포 프로세스에 바로 통합하여 Java WAR 또는 EAR 파일과 같은 소프트웨어 아티팩트를 이미 실행 중인 인프라에 더 이상 배포하지 않도록 하는 것입니다. 대신 빌드 프로세스의 일부로 마이크로서비스와 마이크로서비스가 실행 중인 가상 서버 이미지를 빌드하고 컴파일하려고 합니다. 그런 다음 마이크로 서비스가 배포되면 서버에서 실행 중인 전체 머신 이미지가 배포됩니다. 그림 1.17은 이 과정을 보여줍니다. 이 책의 끝에서 우리는 빌드/배포 파이프라인을 만드는 방법을 살펴볼 것입니다. 12장에서는 다음 패턴과 주제를 다룹니다.

- 빌드 및 배포 파이프라인 —원 버튼 빌드 및 조직의 모든 환경에 배포하는 것을 강조하는 반복 가능한 빌드 및 배포 프로세스를 만드는 방법입니다.

- 코드로서의 인프라 —서비스 프로비저닝을 소스 제어 하에 실행 및 관리할 수 있는 코드로 취급하는 방법.

- 변경할 수 없는 서버 —마이크로서비스 이미지가 생성되면 배포된 후 변경되지 않도록 하는 방법입니다.

- Phoenix 서버 — 개별 컨테이너를 실행하는 서버를 정기적으로 해체하고 변경할 수 없는 이미지에서 다시 생성하도록 하는 방법. 서버가 오래 실행될수록 구성 드리프트의 가능성이 커집니다. 시스템 구성에 대한 임시 변경 사항이 기록되지 않을 때 구성 드리프트가 발생할 수 있습니다.


![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617296956/files/OEBPS/Images/CH01_F17_Huaylupo.png)

그림 1.17 마이크로서비스의 배포와 마이크로서비스가 실행되는 서버가 환경 간에 전체적으로 배포되는 하나의 원자적 아티팩트가 되기를 원합니다.

이러한 패턴과 주제에 대한 우리의 목표는 구성 드리프트가 상위 환경(무대 또는 프로덕션)에 영향을 미치기 전에 최대한 빨리 무자비하게 노출하고 근절하는 것입니다.

> 참고 이 책의 코드 예제(12장 제외)의 경우 모든 것이 데스크탑 컴퓨터에서 로컬로 실행됩니다. 첫 번째 챕터는 기본적으로 명령줄에서 직접 실행할 수 있습니다. 3장부터 모든 코드가 컴파일되고 Docker 컨테이너로 실행됩니다.

이제 책 전체에서 사용할 패턴을 다루었으므로 두 번째 장을 계속하겠습니다. 다음 장에서는 사용할 Spring Cloud 기술, 클라우드 마이크로서비스 지향 애플리케이션 설계를 위한 몇 가지 모범 사례, Spring Boot 및자바.

## 요약

- 모놀리식 아키텍처는 모든 프로세스가 밀접하게 결합되어 있으며 단일 서비스로 실행됩니다.

- 마이크로서비스는 하나의 특정 범위 영역을 담당하는 극히 작은 기능입니다.

- Spring Boot를 사용하면 두 가지 유형의 아키텍처를 모두 만들 수 있습니다.

- 모놀리식 아키텍처는 단순하고 가벼운 애플리케이션에 이상적인 경향이 있으며 마이크로서비스 아키텍처는 일반적으로 복잡하고 진화하는 애플리케이션을 개발하는 데 더 좋습니다. 결국 소프트웨어 아키텍처를 선택하는 것은 프로젝트 규모, 시간 및 요구 사항 등 다른 요소에 전적으로 달려 있습니다.

- Spring Boot는 REST 기반/JSON 마이크로서비스 구축을 단순화합니다. 그 목표는 몇 가지 주석만으로 마이크로서비스를 빠르게 구축할 수 있도록 하는 것입니다.

- 마이크로서비스를 작성하는 것은 쉽지만 프로덕션을 위해 이를 완전히 운영하려면 추가적인 사전 고려가 필요합니다. 핵심 개발, 라우팅 패턴, 클라이언트 복원력, 보안, 애플리케이션 메트릭 및 빌드/배포 패턴을 비롯한 여러 범주의 마이크로 서비스 개발 패턴이 있습니다.

- 마이크로 서비스 라우팅 패턴은 마이크로 서비스를 사용하려는 클라이언트 애플리케이션이 서비스의 위치를 ​​발견하고 서비스로 라우팅되는 방법을 처리합니다.

- 서비스 인스턴스의 문제가 서비스 소비자에게 연쇄적으로 발생하는 것을 방지하려면 클라이언트 복원 패턴을 사용하십시오. 여기에는 실패한 서비스에 대한 호출을 피하기 위한 회로 차단기 패턴, 데이터를 검색하거나 서비스가 실패할 때 특정 작업을 실행하기 위해 대체 경로를 생성하는 폴백 패턴, 가능한 모든 병목 현상을 확장하고 제거하는 클라이언트 로드 밸런싱 패턴이 포함됩니다. 또는 실패 지점 시나리오, 그리고 다른 서비스에 부정적인 영향을 미치는 성능 저하 호출을 중지하기 위해 서비스에 대한 동시 호출 수를 제한하는 벌크헤드 패턴.

- OAuth 2.0은 가장 일반적인 사용자 인증 프로토콜이며 마이크로서비스 아키텍처를 보호하기 위한 탁월한 선택입니다.

- 빌드/배포 패턴을 사용하면 인프라 구성을 빌드/배포 프로세스에 바로 통합할 수 있으므로 Java WAR 또는 EAR 파일과 같은 소프트웨어 아티팩트를 이미 실행 중인 하부 구조에 배포할 필요가 없다.