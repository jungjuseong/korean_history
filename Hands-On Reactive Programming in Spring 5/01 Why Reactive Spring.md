# Why Reactive Spring?

이 장에서는 Reactive의 개념을 설명하고 반응적 접근 방식이 전통적인 접근 방식보다 나은 이유를 살펴봅니다. 이를 위해 기존 접근 방식이 실패한 사례를 살펴보겠습니다. 이 외에도 대부분 반응 시스템이라고 하는 강력한 시스템을 구축하는 기본 원칙을 살펴봅니다. 

또한 반응성이 잘 맞는 비즈니스 사례를 포함하여 분산 서버 간에 메시지 기반 통신을 구축하는 개념적 이유에 대한 개요도 살펴봅니다. 그런 다음 리액티브 프로그래밍의 의미를 확장하여 세분화된 리액티브 시스템을 구축합니다. 

또한 Spring Framework 팀이 Spring Framework 5의 핵심 부분으로 리액티브 접근 방식을 포함하기로 결정한 이유에 대해서도 논의할 것입니다. 이 장의 내용을 기반으로 리액티브의 중요성과 프로젝트를 이전하는 것이 좋은 이유를 이해할 것입니다.

이 장에서는 다음 주제를 다룰 것입니다.

- 반응성이 필요한 이유
- 반응형 시스템의 기본 원리
- 반응형 시스템 설계가 완벽하게 일치하는 비즈니스 사례
- 반응형 시스템에 더 적합한 프로그래밍 기법
- Spring Framework를 반응형으로 옮기는 이유

## Why Reactive?

요즘에는 반응형이 유행어입니다. 너무 흥미롭지만 너무 혼란스럽습니다. 하지만 반응성이 전 세계 컨퍼런스에서 명예로운 자리를 차지하더라도 여전히 그 반응성에 대해 관심을 가져야 할까요? Google에서 `반응형`이라는 단어를 검색하면 프로그래밍 모델의 의미를 정의하는 프로그래밍이 가장 인기 있는 연관임을 알 수 있습니다. 그러나 이것이 반응성의 유일한 의미는 아닙니다. 그 말 이면에는 강력한 시스템 구축을 목표로 하는 숨겨진 기본 설계 원칙이 있습니다. 반응성의 가치를 필수 설계 원칙으로 이해하기 위해 소규모 비즈니스를 개발 중이라고 가정해 보겠습니다.

우리의 비즈니스가 매력적인 가격에 몇 가지 최신 제품을 판매하는 웹 스토어라고 가정해 보겠습니다. 이 분야의 대부분의 프로젝트와 마찬가지로 소프트웨어 엔지니어를 고용하여 발생하는 문제를 해결합니다. 우리는 개발에 대한 전통적인 접근 방식을 선택했고 몇 번의 개발 상호 작용을 통해 스토어를 만들었습니다.

일반적으로 우리 서비스는 시간당 약 1,000명의 사용자가 방문합니다. 일반적인 수요를 충족시키기 위해 우리는 최신 컴퓨터를 구입하고 Tomcat 웹 서버를 실행하고 500개의 할당된 스레드로 Tomcat의 스레드 풀을 구성했습니다. 대부분의 사용자 요청에 대한 평균 응답 시간은 약 250밀리초입니다. 해당 구성의 용량을 순진하게 계산하여 시스템이 초당 약 2,000개의 사용자 요청을 처리할 수 있다고 확신할 수 있습니다. 통계에 따르면 앞서 언급한 사용자의 수는 평균 초당 약 1,000건의 요청을 생성했습니다. 결과적으로 현재 시스템의 용량은 평균 부하에 충분합니다.

요약하자면, 우리는 용량이 여유있게 애플리케이션을 구성했습니다. 게다가 스토어는 11월 마지막 금요일인 블랙프라이데이까지 안정적으로 운영되고 있었습니다.

블랙프라이데이는 고객과 소매업체 모두에게 소중한 날입니다. 고객에게는 할인된 가격으로 상품을 구매할 수 있는 기회입니다. 그리고 소매상에게는 돈을 벌고 제품을 대중화하는 방법입니다. 그러나 이날은 비정상적으로 고객이 몰리는 것이 특징이며, 이는 생산 차질의 주요 원인이 될 수 있다.

그리고 물론, 우리는 실패했습니다! 어느 시점에서 부하가 모든 기대치를 초과했습니다. 스레드 풀에 사용자 요청을 처리하기 위한 빈 스레드가 없었습니다. 결국 백업 서버는 이러한 예측할 수 없는 침입을 처리하지 못했으며, 결국 응답 시간이 증가하고 주기적인 서비스 중단이 발생했습니다. 이 시점에서 우리는 일부 사용자 요청을 잃기 시작했고 마침내 고객은 불만을 갖게 되었고 경쟁업체와 거래하는 것을 선호하게 되었습니다. 이는 모두 업무량 증가에 대응할 수 없다는 사실의 결과였습니다.

이것은 새로운 것이 아닙니다. 한때 아마존과 월마트와 같은 거대 기업도 이 문제에 직면했고 그 이후로 해결책을 찾았습니다. 그럼에도 불구하고 우리는 이전과 같은 길을 따라 강력한 시스템을 설계하고 이에 대한 일반적인 정의를 제공하는 중심 원칙을 이해하게 될 것입니다

To learn more about giants failures see:
- Amazon.com hit with outages  (https://www.cnet.com/news/amazon-com-hit-with-outages/)
- Amazon.com Goes Down, Loses $66,240 Per Minute (https://www.forbes.com/sites/kellyclay/2013/08/19/amazon-com-goes-down-loses-66240-per-minute/#3fd8db37495c)
- Walmart's Black Friday Disaster: Website Crippled, Violence In Stores (https://techcrunch.com/2011/11/25/walmart-black-friday/)

이제 우리 마음속에 남아 있어야 하는 핵심 질문은 “우리는 어떻게 반응해야 합니까?”입니다. 이전에 제공된 예에서 이제 이해할 수 있듯이 응용 프로그램은 변경 사항에 반응해야 합니다. 여기에는 수요(부하)의 변화와 외부 서비스의 가용성 변화가 포함되어야 합니다. 즉, 사용자 요청에 응답하는 시스템 기능에 영향을 줄 수 있는 모든 변경 사항에 반응해야 합니다.

주요 목표를 달성하는 첫 번째 방법 중 하나는 탄력성을 통한 것입니다. 이는 다양한 작업 부하에서 응답성을 유지하는 기능을 설명합니다. 즉, 더 많은 사용자가 사용하기 시작하면 시스템 처리량이 자동으로 증가하고 수요가 감소하면 자동으로 감소해야 합니다. 애플리케이션 관점에서 이 기능은 평균 지연 시간에 영향을 주지 않고 언제든지 시스템을 확장할 수 있기 때문에 시스템 응답성을 가능하게 합니다.

대기 시간은 응답성의 필수 특성입니다. 탄력성이 없으면 수요가 증가하면 평균 대기 시간이 늘어나 시스템의 응답성에 직접적인 영향을 미칩니다. 예를 들어, 추가 계산 리소스 또는 추가 인스턴스를 제공함으로써 시스템의 처리량이 증가할 수 있습니다. 그러면 응답성이 결과적으로 증가합니다. 반면에 수요가 낮으면 시스템이 리소스 소비 측면에서 축소되어 비즈니스 비용을 절감해야 합니다. 수평 또는 수직이 될 수 있는 확장성을 사용하여 탄력성을 얻을 수 있습니다. 그러나 분산 시스템의 확장성을 달성하는 것은 일반적으로 시스템 내에서 병목 현상 또는 동기화 지점의 도입으로 인해 제한되는 과제입니다. 이론적이고 실용적인 관점에서 이러한 문제는 Amdahl의 법칙과 Gunther의 Universal Scalability Model에 의해 설명됩니다. 이에 대해서는 6장, WebFlux 비동기 비차단 통신에서 논의할 것입니다.

여기에서 비즈니스 비용이라는 용어는 추가 클라우드 인스턴스 비용 또는 물리적 시스템의 경우 추가 전력 소비를 나타냅니다. 그러나 장애에 관계없이 응답을 유지할 수 있는 기능 없이 확장 가능한 분산 시스템을 구축하는 것은 어려운 일입니다. 시스템의 한 부분을 사용할 수 없는 상황을 생각해 보겠습니다. 여기에서 외부 결제 서비스가 중단되고 모든 사용자가 상품에 대한 결제를 시도하지 않습니다. 이는 시스템의 응답성을 깨뜨리는 것으로 어떤 경우에는 허용되지 않을 수 있습니다. 예를 들어 사용자가 쉽게 구매를 진행할 수 없는 경우 경쟁업체의 웹 스토어로 이동하게 됩니다. 고품질 사용자 경험을 제공하려면 시스템의 응답성에 관심을 기울여야 합니다. 시스템에 대한 수용 기준은 장애 발생 시 응답성을 유지하는 능력, 즉 탄력성을 유지하는 능력입니다. 이것은 시스템의 기능적 구성 요소 사이에 격리를 적용하여 모든 내부 오류를 격리하고 독립성을 가능하게 함으로써 달성될 수 있습니다. 

Amazon 웹 스토어에는 주문 목록, 결제 서비스, 광고 서비스, 댓글 서비스 등과 같은 다양한 기능 구성 요소가 있습니다. 예를 들어 결제 서비스가 중단된 경우 사용자 주문을 수락한 다음 요청 자동 재시도를 예약하여 원치 않는 실패로부터 사용자를 보호할 수 있습니다. 또 다른 예는 댓글 서비스로부터의 격리일 수 있습니다. 댓글 서비스가 다운되더라도 구매 및 주문 목록 서비스는 영향을 받지 않으며 문제 없이 작동합니다.

또 다른 점은 탄력성과 탄력성이 밀접하게 결합되어 있으며 둘 다 활성화해야 진정한 응답 시스템을 달성할 수 있다는 것입니다. 확장성을 통해 구성 요소의 여러 복제본을 가질 수 있으므로 하나가 실패할 경우 이를 감지하고 시스템의 나머지 부분에 미치는 영향을 최소화하고 다른 복제본으로 전환할 수 있습니다.

To learn more about terminology see the following links:

- 탄력성(https://www.reactivemanifesto.org/glossary#Elasticity)
- 실패(https://www.reactivemanifesto.org/glossary#Failure)
- 격리(https://www.reactivemanifesto.org/glossary#Isolation)
- 컴포넌트(https://www.reactivemanifesto.org/glossary#Component)

## 02 메시지 기반 통신

불분명하게 남아있는 유일한 질문은 분산 시스템의 구성 요소를 연결하고 동시에 분리, 격리 및 확장성을 유지하는 방법입니다. HTTP를 통한 구성 요소 간의 통신을 고려해 보겠습니다. Spring 4에서 HTTP 통신을 수행하는 다음 코드 예제는 이 개념을 나타냅니다.

```java
@RequestMapping("/resource") // (1)
public Object processRequest() {
    RestTemplate template = new RestTemplate(); // (2)

    ExamplesCollection result = template.getForObject // (3) 
       "http://example.com/api/resource2", // 
       ExamplesCollection.class //
    ); //
    ... // (4)
    processResultFurther(result); // (5)
}
```
1. `@RequestMapping` 주석을 사용하는 request 핸들러 매핑 선언입니다.

2. `RestTemplate` 인스턴스를 생성합니다. RestTemplate은 Spring 4에서 서비스 간 요청-응답 통신을 수행하는 웹 클라이언트입니다.

3. 이것은 요청의 구성 및 실행을 보여줍니다. 여기서는 `RestTemplate` API를 사용하여 HTTP 요청을 구성하고 그 직후에 실행합니다. 응답은 자동으로 Java 객체에 매핑되고 실행 결과로 반환됩니다. 응답 본문의 타입은 두 번째 매개변수에 의해 정의됩니다. 

4. 이전 예에서 건너뛴 추가 작업입니다.

5. 다른 처리 단계의 실행입니다.

앞의 예에서 사용자의 요청에 대해 호출될 요청 핸들러를 정의했습니다. 차례로 핸들러를 호출할 때마다 외부 서비스에 대한 추가 HTTP 호출이 생성된 다음 다른 처리 단계가 실행됩니다. 앞의 코드가 논리 면에서 친숙하고 투명해 보일 수 있지만 몇 가지 결함이 있습니다. 이 예에서 무엇이 잘못되었는지 이해하기 위해 다음 요청의 타임라인에 대한 개요를 살펴보겠습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/fb614b5f-a134-493e-a6a7-6b089c8acaff.png)

Diagram 1.1. 컴포넌트 인터랙션 타임라인

이 다이어그램은 해당 코드의 실제 동작을 보여줍니다. 알 수 있듯이 처리 시간의 작은 부분만 효과적인 CPU 사용을 위해 할당되는 반면 나머지 시간 스레드는 I/O에 의해 차단되고 다른 요청을 처리하는 데 사용할 수 없습니다.

C#, Go 및 Kotlin과 같은 일부 언어에서는 녹색 스레드가 사용될 때 동일한 코드가 넌블로킹일 수 있습니다. 그러나 순수한 Java에는 아직 그러한 기능이 없습니다. 결과적으로 이러한 경우 실제 스레드가 차단됩니다.

반면에 Java에는 병렬 처리를 위해 추가 스레드를 할당할 수 있는 스레드 풀이 있습니다. 그러나 높은 부하에서 이러한 기술은 새로운 I/O 작업을 동시에 처리하는 데 매우 비효율적일 수 있습니다. 이 장에서 이 문제를 다시 검토하고 6장, WebFlux 비동기식 비차단 통신에서 철저히 분석합니다.

그럼에도 불구하고 I/O 사례에서 더 나은 리소스 활용을 달성하려면 비동기식 및 넌블로킹 상호 작용 모델을 사용해야 한다는 데 동의할 수 있습니다. 실생활에서 이러한 종류의 커뮤니케이션은 **메시징**입니다. 메시지(SMS 또는 이메일)를 받으면 읽고 응답하는 데 모든 시간이 소요됩니다. 게다가 우리는 보통 대답을 기다리지 않고 그 동안 다른 작업을 합니다. 틀림없이, 이 경우 작업이 최적화되고 나머지 시간이 효율적으로 활용될 수 있습니다. 

다음 다이어그램을 살펴보십시오.

> 용어에 대해 자세히 알아보려면 다음 링크를 참조하십시오.
>
> - Non-Blocking (https://www.reactivemanifesto.org/glossary#Non-Blocking)
> - Resource (https://www.reactivemanifesto.org/glossary#Resource)

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/f2eb9624-2d90-43b8-8b10-fea39c378acf.png)

Diagram 1.2. Non-blocking message communication

**일반적으로 분산 시스템에서 서비스 간 통신 시 효율적인 자원 활용을 위해서는 메시지 기반 통신 원칙을 수용해야 합니다**. 서비스 간의 전반적인 상호 작용은 다음과 같이 설명할 수 있습니다. 각 요소는 메시지 도착을 기다리고 응답합니다. 그렇지 않으면 휴면 상태에 있고 그 반대의 경우 구성 요소는 비차단 방식으로 메시지를 보낼 수 있어야 합니다. 또한, 이러한 통신 접근 방식은 위치 투명성을 가능하게 하여 시스템 확장성을 향상시킵니다. 수신자에게 이메일을 보낼 때 목적지 주소의 정확성에 신경을 씁니다. 그런 다음 메일 서버는 해당 이메일을 수신자의 사용 가능한 장치 중 하나로 배달합니다. 이렇게 하면 특정 장치에 대한 걱정에서 벗어나 수신자가 원하는 만큼 많은 장치를 사용할 수 있습니다. 또한 장치 중 하나에 장애가 발생해도 수신자가 다른 장치에서 이메일을 읽는 것을 방지하지 못하므로 내결함성이 향상됩니다.

메시지 기반 통신을 달성하는 방법 중 하나는 메시지 브로커를 사용하는 것입니다. 이 경우 메시지 대기열을 모니터링하여 시스템에서 부하 관리 및 탄력성을 제어할 수 있습니다. 또한 메시지 통신은 명확한 흐름 제어를 제공하고 전체 디자인을 단순화합니다. 8장, Cloud Streams를 사용한 확장에서 메시지 기반 통신을 달성하기 위해 가장 널리 사용되는 기술을 다루기 때문에 이 장에서 이에 대한 구체적인 세부 사항은 다루지 않을 것입니다.

휴면 상태라는 문구는 메시지 기반 커뮤니케이션을 강조하는 것을 목표로 하는 다음 원본 문서에서 가져왔습니다. 

https://www.reactivemanifesto.org/glossary#Message-Driven.

이전 진술을 모두 수용함으로써 반응 시스템의 기본 원칙을 얻을 수 있습니다. 이것은 다음 다이어그램에 설명되어 있습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/9b452ade-4e5f-4763-87b5-ebf24b228feb.png)
Diagram 1.3. Reactive Manifesto

다이어그램에서 알 수 있듯이 분산 시스템으로 구현된 모든 비즈니스의 주요 가치는 응답성입니다. 반응형 시스템을 달성한다는 것은 탄력성 및 탄력성과 같은 기본 기술을 따르는 것을 의미합니다. 마지막으로 응답성, 탄력성, 탄력성 시스템을 달성하는 기본적인 방법 중 하나는 메시지 기반 통신을 사용하는 것입니다. 또한 이러한 원칙에 따라 구축된 시스템은 시스템의 모든 구성 요소가 독립적이고 적절하게 격리되어 있기 때문에 유지 관리 및 확장이 매우 용이합니다.

Reactive Manifesto에 정의된 모든 개념을 깊이 있게 다루지는 않겠지만 다음 링크에 제공된 용어집을 다시 방문하는 것이 좋습니다.

- https://www.reactivemanifesto.org/glossary.

이러한 모든 개념은 새로운 것이 아니며 반응형 시스템의 개념을 설명하는 용어집인 Reactive Manifesto에 이미 정의되어 있습니다. 이 선언문은 기업과 개발자가 기존의 개념을 동일하게 이해하도록 하기 위해 만들어졌습니다. 강조하자면 리액티브 시스템과 리액티브 매니페스토는 아키텍처와 관련이 있으며 이는 대규모 분산 애플리케이션 또는 소규모 1노드 애플리케이션에 적용될 수 있습니다.

## 반응성 유스케이스

이전 섹션에서 반응성의 중요성과 반응형 시스템의 기본 원리를 배웠고 메시지 기반 통신이 반응형 생태계의 필수 구성 요소인 이유를 보았습니다. 그럼에도 불구하고 우리가 배운 것을 강화하기 위해 실제 적용 사례를 다룰 필요가 있습니다. 먼저 리액티브 시스템은 아키텍처에 관한 것이며 어디에나 적용될 수 있습니다. 단순한 웹사이트, 엔터프라이즈 솔루션, 심지어 고속 스트리밍이나 빅데이터 시스템에서도 사용할 수 있습니다. 그러나 이전 섹션에서 이미 본 웹 스토어의 예를 고려하여 가장 간단한 것부터 시작하겠습니다. 이 섹션에서는 반응형 시스템을 달성하는 데 도움이 될 수 있는 설계의 가능한 개선 및 변경 사항을 다룰 것입니다. 다음 다이어그램은 제안된 솔루션의 전체 아키텍처를 이해하는 데 도움이 됩니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/5b2f69ee-5e37-4585-84e4-f2ec58c51fed.png)

도표 1.4. 스토어 애플리케이션 아키텍처의 예

앞의 다이어그램은 반응형 시스템을 달성할 수 있도록 하는 유용한 사례 목록을 확장합니다. 여기에서 최신 마이크로 서비스 패턴을 적용하여 소규모 웹 스토어를 개선했습니다. 이 경우 위치 투명성을 확보하기 위해 API 게이트웨이 패턴을 사용합니다. 요청 처리를 담당하는 특정 서비스에 대한 지식 없이 특정 리소스의 식별을 제공합니다.

> *info*
> 
> 그러나 이것은 클라이언트가 최소한 리소스 이름을 알고 있어야 함을 의미합니다. API Gateway가 요청 URI의 일부로 서비스 이름을 수신하면 레지스트리 서비스에 요청하여 특정 서비스 주소를 확인할 수 있습니다.

결과적으로 사용 가능한 서비스에 대한 정보를 최신 상태로 유지하는 책임은 서비스 레지스트리 패턴을 사용하여 구현되고 클라이언트 측 검색 패턴의 지원으로 달성됩니다. 이전 예에서 서비스 게이트웨이와 서비스 레지스트리가 동일한 시스템에 설치되어 있다는 점에 유의해야 합니다. 이는 소규모 분산 시스템의 경우에 유용할 수 있습니다. 또한 서비스에 복제를 적용하여 시스템의 높은 응답성을 달성합니다. 

반면 `Apache Kafka`와 독립적인 `Payment Service`(그림 1.4에서 Retry N번 설명이 있는 지점)를 사용하여 적절하게 사용된 메시지 기반 통신을 통해 실패 허용 범위를 확보할 수 있습니다. 외부 시스템. 또한 복제본 중 하나가 중단된 경우에도 복원력을 유지하기 위해 데이터베이스 복제를 사용합니다. 응답을 유지하기 위해 수락된 주문에 대한 응답을 즉시 반환하고 비동기식으로 처리하고 사용자 결제를 결제 서비스로 보냅니다. 최종 알림은 지원되는 채널 중 하나(예: 이메일)를 통해 나중에 전달됩니다. 마지막으로, 이 예는 시스템의 한 부분만을 묘사하며 실제 배포에서는 전체 다이어그램이 더 광범위할 수 있으며 반응 시스템을 달성하기 위한 훨씬 더 구체적인 기술을 도입할 수 있습니다.

8장, Cloud Streams로 확장하기에서 설계 원칙과 장단점을 철저히 다룰 것입니다.
API Gateway, Service Registry 및 분산 시스템 구성을 위한 기타 패턴에 익숙해지려면 http://microservices.io/patterns 링크를 클릭하십시오.

정말 복잡해 보일 수 있는 평범하고 작은 웹 스토어 예제와 함께 반응 시스템 접근 방식이 적절한 또 다른 정교한 영역을 고려해 보겠습니다. 더 복잡하지만 흥미로운 예는 분석입니다. 분석이라는 용어는 방대한 양의 데이터를 처리하고 런타임에 처리하고 실시간 통계를 통해 사용자를 최신 상태로 유지하는 등의 작업을 수행할 수 있는 시스템을 의미합니다. 기지국 사이트 데이터를 기반으로 통신망을 모니터링하는 시스템을 설계한다고 가정합니다. 기지국 수에 대한 최신 통계 보고서로 인해 2016년에 미국에는 308,334개의 활성 사이트가 있었습니다.

미국의 기지국 사이트 수가 포함된 통계 보고서는 다음 링크에서 볼 수 있습니다. 

https://www.statista.com/statistics/185854/monthly-number-of-cell-sites-in-the-united-states-since-june-1986/

불행히도, 우리는 수많은 셀 사이트에 의해 생성되는 실제 부하를 상상할 수 있습니다. 그러나 이처럼 방대한 양의 데이터를 처리하고 통신망 상태, 품질 및 트래픽을 실시간으로 모니터링하는 것은 어려운 일이라는 점에는 동의합니다.

이 시스템을 설계하기 위해 스트리밍이라는 효율적인 아키텍처 기술 중 하나를 따를 수 있습니다. 다음 다이어그램은 이러한 스트리밍 시스템의 추상적인 디자인을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/0b2f7482-fd6e-45bd-b94d-30246fdebf25.png)

Diagram 1.5. 실시간 시스템 아키텍처 분석 예

스트리밍 아키텍처는 데이터 처리 및 변환 흐름의 구성에 관한 것입니다. 일반적으로 이러한 시스템은 낮은 대기 시간과 높은 처리량을 특징으로 합니다. 따라서 통신 네트워크 상태의 분석된 업데이트에 응답하거나 단순히 전달하는 기능이 중요합니다. 따라서 이러한 고가용성 시스템을 구축하려면 Reactive Manifesto에 언급된 기본 원칙에 의존해야 합니다. 예를 들어, 역압 지원을 활성화하여 복원력을 달성할 수 있습니다. 역압은 다른 단계를 압도하지 않는 방식으로 처리 단계 사이의 정교한 작업 부하 관리 메커니즘을 나타냅니다. 효율적인 작업 부하 관리는 내부적으로 메시지를 유지하고 요청 시 메시지를 보낼 수 있는 안정적인 메시지 브로커를 통한 메시지 기반 통신을 사용하여 달성할 수 있습니다.

배압을 처리하는 다른 기술은 3장, Reactive Streams - the New Streams' Standard에서 다룰 것입니다. 또한 시스템의 각 구성 요소를 적절하게 확장하여 시스템 처리량을 탄력적으로 확장하거나 줄일 수 있습니다.

용어에 대한 자세한 내용은 다음 링크를 참조하십시오.

- Backpressure: https://www.reactivemanifesto.org/glossary#Back-Pressure.

실제 시나리오에서 데이터 스트림은 일괄 처리로 처리되는 지속형 데이터베이스이거나 윈도우 또는 머신 러닝 기술을 적용하여 실시간으로 부분적으로 처리될 수 있습니다. 그럼에도 불구하고 Reactive Manifesto에서 제공하는 모든 기본 원칙은 전체 영역이나 비즈니스 아이디어에 관계없이 여기에서 유효합니다.

요약하자면, 반응 시스템을 구축하는 기본 원칙을 적용할 수 있는 다양한 영역이 있습니다. 반응 시스템의 적용 영역은 이전 예제 및 영역에 제한되지 않습니다. 이러한 모든 원칙은 사용자에게 효과적이고 상호 작용적인 피드백을 제공하기 위한 거의 모든 종류의 분산 시스템을 구축하는 데 적용될 수 있기 때문입니다.

그럼에도 불구하고 다음 섹션에서는 Spring Framework를 반응성으로 이동하는 이유를 다룰 것입니다.

## Why Reactive Spring? 

이전 섹션에서 우리는 반응 시스템 접근 방식이 빛을 발하는 몇 가지 흥미로운 예를 살펴보았습니다. 또한 탄력성 및 복원력과 같은 기본 사항의 사용을 확장했으며 반응 시스템을 달성하는 데 일반적으로 사용되는 마이크로서비스 기반 시스템의 예를 보았습니다.

그것은 우리에게 아키텍처 관점에 대한 이해를 줬지만 구현에 대해서는 아무 것도 알려주지 않았습니다. 그러나 반응 시스템의 복잡성을 강조하는 것이 중요하며 이러한 시스템의 구축은 도전 과제입니다. 리액티브 시스템을 쉽게 만들려면 그런 것들을 구축할 수 있는 프레임워크를 먼저 분석한 다음 그 중 하나를 선택해야 합니다. 프레임워크를 선택하는 가장 인기 있는 방법 중 하나는 사용 가능한 기능, 관련성 및 커뮤니티를 분석하는 것입니다.

JVM 세계에서 반응 시스템을 구축하기 위한 가장 일반적으로 알려진 프레임워크는 Akka 및 Vert.x 에코시스템입니다.

한편, Akka는 방대한 기능 목록과 대규모 커뮤니티가 있는 인기 있는 프레임워크입니다. 그러나 초기에 Akka는 Scala 생태계의 일부로 구축되었으며 오랫동안 Scala로 작성된 솔루션 내에서만 그 위력을 보여주었습니다. 스칼라는 JVM 기반 언어임에도 불구하고 자바와는 확연히 다르다. 몇 년 전 Akka는 Java에 대한 직접적인 지원을 제공했지만 어떤 이유에서인지 스칼라에서만큼 Java 세계에서 인기가 없었습니다.

반면에 효율적인 반응 시스템을 구축하기 위한 강력한 솔루션이기도 한 Vert.x 프레임워크가 있습니다. Vert.x는 Java Virtual Machine에서 실행되는 Node.js에 대한 비차단, 이벤트 기반 대안으로 설계되었습니다. 그러나 Vert.x는 불과 몇 년 전부터 경쟁력을 갖기 시작했으며 지난 15년 동안 유연하고 강력한 애플리케이션 개발을 위한 프레임워크 시장은 Spring Framework에 의해 장악되었습니다.

Java 도구 환경에 대한 자세한 정보를 얻으려면 다음 링크를 따르십시오.

https://www.quora.com/Is-it-worth-learning-Java-Spring-MVC-as-of-March-2016/answer/Krishna-Srinivasan-6?srid=xCnf.

Spring Framework는 개발자 친화적인 프로그래밍 모델을 사용하여 웹 애플리케이션을 구축할 수 있는 광범위한 가능성을 제공합니다. 그러나 오랜 시간 동안 강력한 반응 시스템을 구축하는 데 몇 가지 한계가 있었습니다.

## 서비스 레벨에서의 반응성

Reactive 시스템에 대한 수요가 증가하면서 Spring Cloud라는 프로젝트 생성이 시작되었습니다. Spring Cloud Framework는 특정 문제를 해결하고 분산 시스템 구축을 단순화하는 프로젝트의 기초입니다. 결과적으로 Spring Framework 생태계는 우리가 반응형 시스템을 구축하는 것과 관련이 있을 수 있습니다.

해당 프로젝트의 필수 기능, 구성 요소 및 기능에 대해 자세히 알아보려면 http://projects.spring.io/spring-cloud/ 링크를 클릭하십시오.

우리는 이 장에서 Spring Cloud Framework 기능에 대한 세부 사항을 건너뛰고 8장, Cloud Streams로 확장하기에서 반응 시스템 개발에 도움이 되는 가장 중요한 부분을 다룰 것입니다. 그럼에도 불구하고 이러한 솔루션은 최소한의 노력으로 강력하고 반응적인 마이크로서비스 시스템을 구축한다는 점에 유의해야 합니다.

그러나 우수한 Reactive Manifesto에서 알 수 있듯이 전체 설계는 전체 반응 시스템을 구성하는 하나의 요소일 뿐입니다. :

> "대형 시스템은 더 작은 시스템으로 구성되므로 구성 요소의 반응성 속성에 따라 달라집니다. 이는 반응성 시스템이 설계 원칙을 적용하므로 이러한 속성이 모든 규모 수준에서 적용되어 구성될 수 있음을 의미합니다."

따라서 구성 요소 수준에서도 반응형 설계 및 구현을 제공하는 것이 중요합니다. 이러한 맥락에서 디자인 원칙이라는 용어는 구성 요소 간의 관계와 예를 들어 요소를 합성하는 데 사용되는 프로그래밍 기술을 나타냅니다. Java로 코드를 작성하는 가장 인기 있는 전통적인 기술은 명령형 프로그래밍입니다.

명령형 프로그래밍이 반응 시스템 설계 원칙을 따르는지 이해하기 위해 다음 다이어그램을 살펴보겠습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/415cdc25-f8f3-468a-a3e0-7f2291c4f2f1.png)

Diagram 1.6. UML Schema of component relationship

여기 웹 스토어 애플리케이션 내에 두 가지 구성 요소가 있습니다. 
이 경우 OrdersService는 사용자 요청을 처리하는 동안 ShoppingCardService를 호출합니다. 내부에서 ShoppingCardService가 HTTP 요청 또는 데이터베이스 쿼리와 같은 장기 실행 I/O 작업을 실행한다고 가정합니다. 명령형 프로그래밍의 단점을 이해하기 위해 위에서 언급한 구성 요소 간의 상호 작용에 대한 가장 일반적인 구현의 다음 예를 살펴보겠습니다.

```java
interface ShoppingCardService { // (1)
   Output calculate(Input value); //
} //

class OrdersService { // (2)
   private final ShoppingCardService scService; //
                                                                   //
   void process() { //
      Input input = ...; //
      Output output = scService.calculate(input); // (2.1)
      ... // (2.2)
   } //
} //
```
앞서 언급한 코드는 다음과 같이 설명됩니다.

(1) ShoppingCardService 인터페이스 선언입니다. 이것은 앞서 언급한 클래스 다이어그램에 해당하며 하나의 인수를 받아들이고 처리 후 응답을 반환하는 하나의 계산 메서드만 있습니다.

(2) OrderService 선언입니다. 여기 (2.1) 지점에서 동기적으로 ShoppingCardService를 호출하고 실행 직후에 결과를 수신합니다. (2.2)는 결과 처리를 담당하는 나머지 코드를 숨깁니다.

(3) 우리 서비스는 시간에 밀접하게 연결되거나 단순히 OrderService의 실행이 ShoppingCardService의 실행과 밀접하게 연결됩니다. 불행히도 이러한 기술을 사용하면 ShoppingCardService가 처리 단계에 있는 동안 다른 작업을 진행할 수 없습니다.

Java에서 scService.calculate(input) 실행은 OrdersService 논리 처리가 발생하는 스레드를 차단합니다. 따라서 OrderService에서 별도의 독립적인 처리를 실행하려면 추가 스레드를 할당해야 합니다. 이 장에서 볼 수 있듯이 추가 스레드를 할당하는 것은 낭비일 수 있습니다. 결과적으로 반응 시스템 관점에서 이러한 시스템 동작은 용납될 수 없습니다.

블로킹 통신은 명시적으로 비차단 통신을 제공하는 메시지 기반 원칙과 직접적으로 모순됩니다. 이에 대한 자세한 내용은 https://www.reactivemanifesto.org/#message-driven을 참조하십시오.

그럼에도 불구하고 Java에서 해당 문제는 구성 요소 간 통신을 위해 콜백 기술을 적용하여 해결할 수 있습니다.

```java
interface ShoppingCardService { // (1)
   void calculate(Input value, Consumer<Output> c); //
} //

class OrdersService { // (2)
   private final ShoppingCardService scService; // 

   void process() { //
      Input input = ...; //
      scService.calculate(input, output -> { // (2.1)
         ... // (2.2)
      }); //
   } //
} //
```

이전 코드의 각 지점은 다음 번호 목록에 설명되어 있습니다.

(1) 앞의 코드는 ShoppingCardService 인터페이스 선언입니다. 이 경우, `calculate()` 메소드는 두 개의 매개변수를 받고 void를 리턴합니다. 즉, 디자인 관점에서 호출자는 대기 상태에서 즉시 해제될 수 있으며 결과는 나중에 지정된 Consumer<> 콜백으로 전송됩니다.

(2) OrderService 선언입니다. 여기에서 (2.1) 지점에서 비동기적으로 ShoppingCardService를 호출하고 처리를 계속합니다. 차례로 ShoppingCardService가 콜백 함수를 실행하면 실제 결과 처리(2.2)를 진행할 수 있습니다.

이제 `OrdersService`는 작업이 끝날 때 반응하도록 함수 콜백을 전달합니다. 이것은 `OrdersService`가 이제 `ShoppingCardService`에서 분리되고 첫 번째 것은 주어진 함수를 호출하는 `ShoppingCardService#calculate` 메소드의 구현이 동기식 또는 비동기식일 수 있는 기능적 콜백을 통해 알림을 받을 수 있다는 사실입니다.

```java
class SyncShoppingCardService implements ShoppingCardService { // (1)
   public void calculate(Input value, Consumer<Output> c) { //
      Output result = new Output(); //
      c.accept(result); // (1.1)
   } //
} //

class AsyncShoppingCardService implements ShoppingCardService { // (2)
   public void calculate(Input value, Consumer<Output> c) { //
      new Thread(() -> { // (2.1)
         Output result = template.getForObject(...); // (2.2) 
         ... //
         c.accept(result); // (2.3)
      }).start(); // (2.4)
   } //
} 
//
```
이전 코드의 각 지점은 다음 번호 목록에 설명되어 있습니다.

(1) `SyncShoppingCardService` 클래스 선언입니다. 이 구현에서는 차단 작업이 없다고 가정합니다. I/O 실행이 없기 때문에 결과를 콜백 함수(1.1)에 전달하여 즉시 반환할 수 있습니다.

(2) `AsyncShoppingCardService` 클래스 선언입니다. 이 경우 항목(2.2)에 표시된 대로 차단 I/O가 있는 경우 별도의 스레드(2.1)(2.4)로 래핑할 수 있습니다. 결과를 검색한 후 처리되어 콜백 함수에 전달됩니다.

이 예에는 동기 범위를 유지하고 API 관점에서 이점을 제공하지 않는 ShoppingCardService의 동기화 구현이 있습니다. 비동기의 경우 비동기 경계를 달성하고 별도의 스레드에서 요청이 실행됩니다. OrdersService는 실행 프로세스에서 분리되고 콜백 실행으로 완료 알림을 받습니다.

이 기술의 장점은 구성 요소가 콜백 함수에 의해 제때 분리된다는 것입니다. 즉, scService.calculate 메서드를 호출한 후 ShoppingCardService의 차단 방식으로 응답을 기다리지 않고 즉시 다른 작업을 진행할 수 있습니다.

단점은 콜백을 사용하려면 개발자가 공유 데이터 수정 및 콜백 지옥의 함정을 피하기 위해 멀티 스레딩에 대한 충분한 이해가 필요하다는 것입니다.

사실 `콜백 지옥`이라는 표현은 자바스크립트(http://callbackhell.com)와 관련하여 언급되지만 자바에도 적용됩니다. 다행히도 콜백 기술이 유일한 옵션은 아닙니다. 다른 하나는 `java.util.concurrent.Future`로, 어느 정도 실행 동작을 숨기고 구성 요소도 분리합니다.

```java
interface ShoppingCardService { // (1)
   Future<Output> calculate(Input value); // 
} //

class OrdersService { // (2)
   private final ShoppingCardService scService; //
 //
   void process() { //
      Input input = ...; //
      Future<Output> future = scService.calculate(input); // (2.1)
      ... //
      Output output = future.get(); // (2.2)
      ... //
   } //
} //
```

The numbered points are described in the following:

(1) 이 시점에서 ShoppingCardService 인터페이스 선언이 있습니다. 여기에서, 계산 메소드는 하나의 매개변수를 받아들이고 `Future`를 리턴합니다. `Future`는 사용 가능한 결과가 있는지 확인하거나 그것을 얻기 위해 차단하는 클래스 래퍼입니다.

(2) OrderService 선언입니다. 여기 (2.1) 지점에서 비동기적으로 ShoppingCardService를 호출하고 `Future` 인스턴스를 수신합니다. 결과가 비동기적으로 처리되는 동안 계속 처리할 수 있습니다. ShoppingCardService#calculation과 독립적으로 수행될 수 있는 일부 실행 후에 결과를 얻습니다. 이 결과는 차단 방식으로 기다리거나 결과를 즉시 반환할 수 있습니다(2.2).

이전 코드에서 알 수 있듯이 `Future` 클래스를 사용하면 결과를 지연 검색합니다. `Future` 클래스의 지원으로 우리는 콜백 지옥을 피하고 특정 Future 구현 뒤에 다중 스레딩 복잡성을 숨깁니다. 어쨌든, 우리가 필요한 결과를 얻으려면 잠재적으로 현재 스레드를 차단하고 확장성을 눈에 띄게 감소시키는 외부 실행과 동기화해야 합니다.

개선 사항으로 Java 8은 `CompletionStage에` 대한 직접 구현으로 `CompletionStage` 및 `CompletableFuture를` 제공합니다. 차례로 이러한 클래스는 약속과 유사한 API를 제공하고 다음과 같은 코드를 빌드할 수 있도록 합니다.

To learn more about futures and promises, please see the following link: https://en.wikipedia.org/wiki/Futures_and_promises.

```java
interface ShoppingCardService { // (1)
   CompletionStage<Output> calculate(Input value);                 //
}                                                                  //

class OrdersService { // (2)
   private final ComponentB componentB;                            //
   void process() {                                                //
      Input input = ...;                                           //
      componentB.calculate(input) // (2.1)
                .thenApply(out1 -> { ... }) // (2.2)
                .thenCombine(out2 -> { ... })                      //       
                .thenAccept(out3 -> { ... })                       //
   }                                                               //
}          
                                                        //
```
앞서 언급한 코드는 다음과 같이 설명됩니다.

(1) 이 시점에서 ShoppingCardService 인터페이스 선언이 있습니다. 이 경우, 계산 메소드는 하나의 매개변수를 허용하고 CompletionStage를 리턴합니다. CompletionStage는 Future와 유사하지만 반환된 결과를 기능적 선언 방식으로 처리할 수 있는 클래스 래퍼입니다.

(2) 이것은 OrderService 선언입니다. 여기(2.1) 지점에서 비동기적으로 ShoppingCardService를 호출하고 실행 결과로 CompletionStage를 즉시 수신합니다. CompletionStage의 전반적인 동작은 Future와 유사하지만 CompletionStage는 thenAccept 및 thenCombine과 같은 메서드를 작성할 수 있는 유창한 API를 제공합니다. 이들은 결과에 대한 변환 작업을 정의하고 변환된 결과를 처리하기 위해 최종 소비자를 정의하는 thenAccept를 정의합니다.

CompletionStage의 지원으로 기능적이고 선언적인 스타일로 코드를 작성할 수 있습니다. 코드는 깔끔해 보이고 결과를 비동기식으로 처리합니다. 또한, 대기 중인 결과를 생략하고 결과가 사용 가능할 때 처리하는 기능을 제공할 수 있습니다. 게다가, 이전의 모든 기술은 Spring 팀에 의해 평가되었으며 프레임워크 내의 대부분의 프로젝트에서 이미 구현되었습니다. CompletionStage가 효율적이고 읽기 쉬운 코드를 작성할 수 있는 더 나은 가능성을 제공하지만 불행히도 일부 누락된 점이 있습니다. 예를 들어 Spring 4 MVC는 CompletionStage를 오랫동안 지원하지 않았고 이를 위해 자체 ListenableFuture를 제공했습니다. 이것은 Spring 4가 이전 Java 버전과 호환되는 것을 목표로 했기 때문에 발생했습니다. Spring의 ListenableFuture로 작업하는 방법을 이해하기 위해 AsyncRestTemplate 사용법에 대한 개요를 살펴보겠습니다. 다음 코드는 AsyncRestTemplate과 함께 ListenableFuture를 사용하는 방법을 보여줍니다.

```java
AsyncRestTemplate template = new AsyncRestTemplate(); 
SuccessCallback onSuccess = r -> { ... }; 
FailureCallback onFailure = e -> { ... }; 
ListenableFuture<?> response = template.getForEntity(
   "http://example.com/api/examples", 
   ExamplesCollection.class 
);
response.addCallback(onSuccess, onFailure);
```

앞의 코드는 비동기 호출을 처리하기 위한 콜백 스타일을 보여줍니다. 본질적으로 이 통신 방법은 더티 핵이고 Spring Framework는 차단 네트워크 호출을 별도의 스레드 내부에 래핑합니다. 게다가 Spring MVC는 모든 구현이 요청당 스레드 모델을 사용하도록 의무화하는 Servlet API에 의존합니다.

`Spring Framework 5`와 새로운 `Reactive WebClient`의 출시로 모든 서비스 간 통신은 더 이상 차단되지 않습니다. 또한 Servlet 3.0은 비동기식 클라이언트-서버 통신을 도입했고 Servlet 3.1은 I/O에 대한 비차단 쓰기를 허용했으며 일반적으로 Servlet 3 API의 새로운 비동기 비차단 기능은 Spring MVC에 잘 통합되었습니다. 

그러나 유일한 문제는 Spring MVC가 향상된 서블릿의 모든 이점을 무효화하는 즉시 사용 가능한 비동기 비차단 클라이언트를 제공하지 않았다는 것입니다. 이 모델은 최적이 아닙니다. 이 기술이 왜 비효율적인지 이해하려면 다중 스레딩 비용을 다시 살펴봐야 합니다. 

한편, 멀티스레딩은 본질적으로 복잡한 기술입니다. 멀티 스레딩으로 작업할 때 다른 스레드에서 공유 메모리 액세스, 동기화, 오류 처리 등과 같은 많은 것을 고려해야 합니다. 결과적으로 Java의 다중 스레딩 설계에서는 소수의 스레드가 단일 CPU를 공유하여 작업을 동시에 실행할 수 있다고 가정합니다. CPU 시간이 여러 스레드 간에 공유된다는 사실은 컨텍스트 전환 개념을 도입합니다. 이것은 스레드를 나중에 다시 시작하려면 일반적으로 계산 집약적인 작업인 레지스터, 메모리 맵 및 기타 관련 요소를 저장하고 로드해야 함을 의미합니다. 결과적으로 활성 스레드 수가 많고 CPU가 적은 응용 프로그램은 비효율적입니다.

컨텍스트 전환 비용에 대해 자세히 알아보려면 https://en.wikipedia.org/wiki/Context_switch#Cost 링크를 방문하세요.

Java 스레드는 메모리 소비에 오버헤드가 있습니다. 64비트 Java VM에서 스레드의 일반적인 스택 크기는 1,024KB입니다. 한편, 연결 모델당 스레드에서 ~6,4000개의 동시 요청을 처리하려는 시도는 약 64GB의 메모리를 사용할 수 있습니다. 이는 비즈니스 관점에서 비용이 많이 들거나 애플리케이션 관점에서 중요할 수 있습니다. 반면에 제한된 크기와 요청에 대해 미리 구성된 대기열이 있는 기존 스레드 풀로 전환하면 클라이언트가 응답을 너무 오래 기다리며 이는 덜 안정적이고 평균 응답 시간 초과를 증가시키며 결국 응답하지 않을 수 있습니다.

이를 위해 Reactive Manifesto에서는 Non-blocking 작업을 사용할 것을 권장하며 이는 Spring 생태계에서 누락된 사항입니다. 반면 Netty와 같은 반응형 서버와의 통합이 제대로 이루어지지 않아 컨텍스트 스위칭 문제가 해결됩니다.

평균 연결 수에 대한 소스 정보를 얻으려면 다음 링크를 참조하십시오. https://stackoverflow.com/questions/2332741/what-is-the-theoretical-maximum-number-of-open-tcp-connections-that- a-modern-lin/2332756#2332756.

스레드라는 용어는 스레드 개체에 할당된 메모리와 스레드 스택에 할당된 메모리를 나타냅니다. 자세한 내용은 다음 링크를 참조하세요.
http://xmlandmore.blogspot.com/2014/09/jdk-8-thread-stack-size-tuning.html?m=1.

비동기 처리는 일반 요청-응답 패턴에 국한되지 않으며 때로는 무한한 데이터 스트림을 처리해야 하며 배압 지원을 통해 정렬된 변환 흐름 방식으로 처리해야 합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/dd61e16e-bcb8-4a11-865a-ddefff7e8190.png)

Diagram 1.7. Reactive pipeline example

이러한 경우를 처리하는 방법 중 하나는 변환 단계를 연결하여 비동기식 이벤트 처리 기술을 수용하는 Reactive 프로그래밍을 사용하는 것입니다. 결과적으로 반응형 프로그래밍은 반응형 시스템의 설계 요구 사항에 맞는 좋은 기술입니다. 우리는 다음 장에서 반응 시스템을 구축하기 위해 반응형 프로그래밍을 적용하는 것의 가치를 다룰 것입니다.

불행히도 반응 프로그래밍 기술은 Spring Framework 내부에 잘 통합되지 않았습니다. 이는 현대적인 애플리케이션 구축에 또 다른 제한을 가하고 프레임워크의 경쟁력을 감소시켰습니다. 결과적으로 리액티브 시스템과 리액티브 프로그래밍에 대한 과대 광고에서 언급된 모든 격차는 프레임워크 내에서 극적인 개선의 필요성을 증가시켰습니다. 

마지막으로 모든 수준에서 Reactivity에 대한 지원을 추가하고 개발자에게 반응형 시스템 개발을 위한 강력한 도구를 제공함으로써 Spring Framework의 개선을 크게 자극했습니다. 핵심 개발자는 반응형 시스템 기반으로서 Spring Framework의 전체 기능을 드러내는 새로운 모듈을 구현하기로 결정했습니다.

## 요약

이 장에서는 오늘날 자주 발생하는 비용 효율적인 IT 솔루션에 대한 요구 사항을 강조했습니다. Amazon 같은 기업이 기존의 아키텍처 패턴을 현재 클라우드 기반 분산 환경에서 원활하게 작동하도록 강제하지 못하는 이유와 방법을 설명했습니다.

또한 편리하고 효율적이며 지능적인 디지털 서비스에 대한 계속 증가하는 요구를 충족시키기 위해 새로운 아키텍처 패턴 및 프로그래밍 기술에 대한 필요성을 설정했습니다. Reactive Manifesto를 통해 우리는 반응성이라는 용어를 분해하고 이해했으며 탄력성, 탄력성 및 메시지 중심 접근 방식이 디지털 시대의 주요 비기능적 시스템 요구 사항인 응답성을 달성하는 데 도움이 되는 이유와 방법을 설명했습니다. 물론 리액티브 시스템이 빛을 발하며 기업이 목표를 쉽게 달성할 수 있도록 하는 사례를 제시했습니다.

이 장에서 우리는 아키텍처 패턴으로서의 리액티브 시스템과 프로그래밍 기술로서의 리액티브 프로그래밍 사이의 명확한 차이점을 강조했습니다. 우리는 이 두 가지 유형의 반응성이 함께 잘 작동하고 고효율의 강력한 IT 솔루션을 생성할 수 있도록 하는 방법과 이유를 설명했습니다.

Reactive Spring 5에 대해 더 깊이 들어가려면 반응 프로그래밍 기초에 대한 확실한 이해를 얻고 기술을 결정하는 필수 개념과 패턴을 배워야 합니다. 따라서 다음 장에서 우리는 반응형 프로그래밍의 핵심, 그 역사, 자바 세계에서 반응형 환경의 상태를 배울 것입니다.