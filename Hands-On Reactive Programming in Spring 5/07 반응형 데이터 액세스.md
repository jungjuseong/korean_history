# 반응형 DB 액세스

이전 장에서는 Spring Framework 제품군에 새로 추가된 Spring WebFlux를 소개했습니다. 이 추가 기능은 애플리케이션 전면에 반응 프로그래밍을 제공하고 모든 종류의 HTTP 요청에 대한 비차단 처리를 가능하게 합니다.

이 장에서는 Spring Data 모듈을 사용하여 반응적인 방식으로 데이터에 액세스하는 방법을 배웁니다. 이 기능은 사용 가능한 모든 컴퓨팅 리소스를 가장 효율적으로 활용하여 최대의 비즈니스 가치를 제공하고 동시에 최소한의 운영 비용을 요구하는 완전히 반응적이고 반응이 빠른 애플리케이션을 만드는 데 필수적입니다.

우리가 선택한 DB가 반응형 또는 비동기식 드라이버를 제공하지 않더라도 전용 스레드 풀을 사용하여 이에 대한 반응형 응용 프로그램을 구축하는 것은 여전히 ​​가능합니다. 이 장에서는 이를 수행하는 방법을 다룹니다. 그러나 I/O를 차단하는 것은 반응형 애플리케이션에서 항상 권장되지 않습니다.

이 장에서는 다음 주제를 다룹니다.

- 최근의 데이터 저장 및 데이터 처리 패턴
- 동기 데이터 액세스의 장단점
- Spring Data가 반응형 데이터 액세스를 허용하는 방법 및 반응 애플리케이션에서 이를 사용하는 방법
- 현재 사용 가능한 반응성 커넥터
- 반응형 프로그래밍 모델에 차단 I/O를 적용하는 방법


## 1. 데이터 처리 패턴

모놀리식 소프트웨어 시스템이 여전히 존재하고 많은 일상 활동에서 작동하고 지원하지만 대부분의 새로운 시스템은 마이크로서비스용으로 설계되었거나 적어도 어느 시점에서는 마이크로서비스로 전환됩니다. 

마이크로서비스는 아마도 클라우드 애플리케이션을 위한 가장 지배적인 아키텍처 스타일일 것입니다. 대부분의 경우 이 접근 방식은 소프트웨어 제품의 빠른 개발 주기를 허용합니다. 
동시에 특히 AWS, Google Cloud Platform 또는 Pivotal Cloud Foundry와 같은 클라우드 제공업체에 의존할 때 보다 비용 효율적인 기본 인프라(서버, 네트워킹, 백업 등)에 대한 기회를 제공합니다.

클라우드 네이티브 애플리케이션에 대한 자세한 내용은 https://cncf.io/about/charter에서 CNCF(Cloud Native Computing Foundation) 헌장을 참조하십시오. 반응형 프로그래밍의 맥락에서 클라우드 네이티브 응용 프로그램의 더 많은 장단점은 "10장, 그리고 마지막으로 출시"에서 다룹니다!

이제 마이크로서비스, 가능한 전략, 구현 접근 방식 및 데이터 지속성과 관련된 몇 가지 권장 사항의 맥락에서 데이터 저장의 기본 사항에 대한 개요를 살펴보겠습니다.

### Domain-driven design

Eric Evans(Addison-Wesley, 2004)의 DDD(Domain-Driven Design)는 모든 소프트웨어 엔지니어의 책장에서 명예로운 자리를 차지해야 합니다. 이는 성공적인 마이크로서비스 아키텍처를 위한 중요한 이론적 기반을 정의하고 공식화하기 때문입니다. DDD는 공통 어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델 무결성을 유지하기 위한 일련의 원칙을 공식화합니다. DDD의 가장 중요한 결과 중 하나는 DDD로 정의된 개별 경계 컨텍스트가 일반적으로 다음과 같이 별도의 마이크로서비스에 매핑된다는 것입니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/4b9cb50a-11d2-4941-a7f6-18a4ba1e755d.png)

다이어그램 7.1 Implementing Domain-Driven Design and Domain-Driven Design Distilled의 저자인 Vaughn Vernon이 묘사한 바운디드 컨텍스트

DDD는 비즈니스 핵심 도메인, 특히 도메인 모델을 표현, 생성 및 검색하기 위한 아티팩트에 매우 집중하기 때문에 이 장에서 엔티티, 값 개체, 집계, 저장소와 같은 개체가 자주 참조됩니다.

DDD 개념에 대해 자세히 알아보려면 http://dddcommunity.org/resources/ddd_terms 문서를 참조하십시오.

DDD를 염두에 두고 애플리케이션을 구현하는 동안 서비스에 이러한 레이어가 있는 경우 이전 개체를 애플리케이션 지속성 레이어에 매핑해야 합니다. 이러한 도메인 모델은 논리적 및 물리적 데이터 모델의 기초를 공식화합니다.

### 마이크로서비스 시대의 데이터 저장소

아마도 마이크로서비스 아키텍처에 의해 도입된 지속성 관련 주요 변경 사항은 서비스 간에 데이터 저장소를 공유하지 않도록 하는 강력한 권장 사항일 것입니다. 즉, 각 논리적 서비스가 해당 DB를 소유하고 관리하며(DB가 전혀 필요한 경우) 이상적으로 다른 서비스는 서비스 API 호출과 다른 방식으로 데이터에 액세스할 수 없습니다.

이러한 분리의 모든 이유를 설명하는 것은 이 책의 범위를 벗어나지만 가장 중요한 이유는 다음과 같습니다.

- DB 스키마에 대한 긴밀한 결합 없이 서로 다른 서비스를 개별적으로 발전시키는 기능
- 보다 정확한 자원 관리의 가능성
- 수평적 확장 가능성
- 최적의 지속성 구현 사용 가능성

다음 다이어그램을 고려하십시오.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/a01be237-dbab-444d-a129-19bd147059af.png)

다이어그램 7.2 서비스별 별도의 DB

물리적 수준에서 저장소 분리는 몇 가지 다른 방법으로 구현할 수 있습니다. 

가장 간단한 방법은 모든 서비스에 대해 하나의 DB 서버와 하나의 DB를 가지지만 별도의 스키마(마이크로 서비스당 스키마)를 사용하여 나누는 것입니다. 이러한 구성은 쉽게 구현할 수 있고 최소한의 서버 리소스가 필요하며 프로덕션에서 많은 관리가 필요하지 않으므로 응용 프로그램 개발의 첫 번째 단계에서 매우 매력적입니다. 

DB 액세스 제어 규칙을 사용하여 데이터 분리를 시행할 수 있습니다. 이러한 접근 방식은 구현하기 쉽지만 동시에 깨기 쉽습니다. 데이터가 동일한 DB에 저장되기 때문에 개발자가 둘 이상의 서비스에 속한 데이터를 검색하거나 업데이트할 수 있는 단일 쿼리를 작성하고 싶을 때가 있습니다. 또한 하나의 서비스만 손상시켜 전체 시스템의 보안을 손상시키는 것이 더 쉽습니다. 

다음 다이어그램은 언급된 시스템의 설계를 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/15d3bb07-91dc-4cea-9a0f-bce01549fb49.png)

다이어그램 7.3 서비스별 스키마

서비스는 단일 DB 서버를 공유할 수 있지만 다른 액세스 자격 증명을 가진 다른 DB를 가질 수 있습니다. 이러한 접근 방식은 외부 데이터에 액세스할 수 있는 단일 쿼리를 작성하는 것이 훨씬 더 어렵기 때문에 데이터 분리를 개선합니다. 그러나 이것은 또한 백업 루틴을 약간 복잡하게 만듭니다. 

다음 다이어그램은 이를 설명합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/13874a3e-f7fd-4ad4-b43e-2d881b67b7d5.png)

다이어그램 7.4 서비스별 DB

각 서비스에는 DB 서버가 있을 수 있습니다. 이러한 접근 방식은 훨씬 더 많은 관리가 필요하지만 구체적인 서비스의 요구 사항을 충족하기 위해 DB 서버를 미세 조정하기 위한 좋은 출발점을 제공합니다. 또한 이 경우 이러한 확장성을 필요로 하는 DB의 수직적, 수평적 확장만 가능하다. 다음 다이어그램은 이를 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/a067ae64-deac-4785-bca8-eb7976e44699.png)

그림 7.5 서비스별 DB 서버

소프트웨어 시스템을 구현할 때 앞에서 언급한 모든 기술은 시스템의 실제 요구 사항에 따라 다른 비율로 동시에 쉽게 사용할 수 있습니다. 다음 스키마는 이러한 시스템의 설계를 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/a7c4f1e6-812b-46ba-ac1a-3c87b4286b1f.png)

도표 7.6 지속성 전략의 혼합 조합

또한 서로 다른 DB 서버 인스턴스를 가질 수 있으며 이제 서로 다른 DB 엔진(SQL 및 NoSQL)을 함께 사용하여 최상의 결과를 얻을 수 있습니다. 이 접근 방식을 다중 언어 지속성이라고 합니다.

### 다중 언어 지속성

2006년 Neal Ford는 다중 언어 프로그래밍이라는 용어를 제안했습니다. 이것은 소프트웨어 시스템이 비즈니스 또는 기술 컨텍스트에서 가장 적합한 언어에서 가장 큰 향상을 얻기 위해 다양한 언어를 혼합하여 작성될 수 있다는 아이디어를 나타냅니다. 그 후 특정 영역에서 최고가 되거나 여러 영역에서 우수하다는 의도로 많은 새로운 프로그래밍 언어가 도입되었습니다.

동시에 데이터 지속성 영역에서 또 다른 유사한 사고가 발생했습니다. 이로 인해 사람들은 비즈니스 또는 기술 요구 사항에 따라 서로 다른 애플리케이션 부분이 서로 다른 지속성 기술을 사용하면 어떻게 되는지 의문을 갖게 되었습니다. 예를 들어, 분산 웹 애플리케이션에 대한 HTTP 세션을 저장하고 소셜 네트워크에 친구 그래프를 저장하려면 서로 다른 운영 특성이 필요하고 결과적으로 서로 다른 DB가 필요합니다. 오늘날에는 시스템이 동시에 두 가지 이상의 서로 다른 DB 기술을 사용하는 것이 표준입니다.

역사적으로 대부분의 관계형 DB 관리 시스템(RDBMS)은 동일한 ACID 원칙을 기반으로 구축되었으며 스토리지와 통신하기 위해 매우 유사한 SQL 언어를 제공합니다. 일반적으로 RDBMS는 광범위한 응용 프로그램에 적합하지만 많은 일반적인 사용 사례(예: 그래프 저장, 메모리 내 저장소 및 분산 저장소)에 대해 최상의 성능 및 운영 기능을 가진 경우는 드뭅니다. 대조적으로, 최근에 등장한 NoSQL DB는 기본 원칙의 스펙트럼이 더 넓기 때문에 대부분의 NoSQL DB가 범용 데이터 저장소 역할을 효율적으로 수행할 수 없음에도 불구하고 일반적인 사용 사례에 대해 더 나은 기능을 제공합니다. 

다음 다이어그램은 이를 설명합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/500aba34-6ff9-449a-b4ba-3f2740509d58.png)

다이어그램 7.7 각 서비스는 요구 사항에 가장 적합한 지속성 기술을 사용합니다.

또한, 다중 언어 지속성은 복잡성의 추가 비용으로 발생합니다. 각각의 새로운 스토리지 메커니즘은 학습할 새로운 API 및 패러다임, 개발 또는 채택할 새로운 클라이언트 라이브러리, 개발 및 프로덕션에서 해결해야 할 새로운 표준 문제 세트를 도입합니다. 또한 NoSQL DB를 잘못 사용하면 서비스가 완전히 재설계될 수 있습니다. 올바른 지속성 기술(SQL 또는 NoSQL)을 사용하면 이를 더 편안하게 만들 수 있지만 문제는 해결되지 않습니다.

Spring Data(http://projects.spring.io/spring-data)라는 데이터 지속성을 전담하는 별도의 하위 프로젝트가 있습니다. 이 장의 나머지 부분에서는 Spring Data에서 사용할 수 있는 다양한 설계 접근 방식과 DB 커넥터, 특히 반응형 프로그래밍 패턴을 대상으로 하고 애플리케이션이 다중 언어 지속성 계층에 저장된 데이터에 액세스하는 방식을 변경하는 방법을 설명합니다.

## 서비스로서의 DB

적절하게 설계된 마이크로서비스 아키텍처에서 모든 서비스는 상태 비저장이며 모든 상태는 데이터 지속성을 관리하는 방법을 알고 있는 특수 서비스에 저장됩니다. 클라우드 환경에서 상태 비저장 서비스는 효율적인 확장성과 고가용성을 가능하게 합니다. 그러나 DB 서버, 특히 클라우드용으로 설계되지 않은 DB 서버를 효율적으로 관리하고 확장하는 것은 훨씬 더 어렵습니다. 대부분의 클라우드 공급자는 DBaaS(Database as a Service) 솔루션을 사용하여 이러한 문제를 해결할 것을 제안합니다. 이러한 스토리지 솔루션은 일반 DB(MySQL, PostgreSQL 및 Redis)의 사용자 지정 버전이거나 클라우드(AWS Redshift, Google BigTable 및 Microsoft CosmosDB)에서만 작동하도록 처음부터 설계될 수 있습니다.

일반적으로 클라우드 스토리지 또는 DB 사용 알고리즘은 다음과 같은 방식으로 작동합니다.

1. 클라이언트는 DB 또는 파일 저장소에 대한 액세스 요청을 발행합니다(관리자 페이지 또는 API를 통해).
2. 클라우드 공급자는 데이터 지속성을 위해 사용할 수 있는 API 또는 서버 리소스에 대한 액세스 권한을 부여합니다. 동시에 클라이언트는 제공된 API가 어떻게 구현되는지 알지 못하거나 관심조차 갖지 않습니다.
3. 클라이언트는 액세스 자격 증명을 제공하는 스토리지 API 또는 DB 드라이버를 사용합니다.
4. 클라우드 공급자는 클라이언트 구독 계획, 저장된 데이터 크기, 쿼리 빈도, 동시 연결 또는 기타 특성에 따라 클라이언트에 요금을 청구합니다.

일반적으로 이러한 접근 방식을 통해 클라이언트(이 경우 소프트웨어 개발자)와 클라우드 공급자는 기본 목표에 집중할 수 있습니다. 클라우드 제공자는 클라이언트 데이터를 저장하고 처리하는 가장 효율적인 방법을 구현하여 기본 인프라에 대한 지출을 최소화합니다. 동시에 클라이언트는 애플리케이션의 주요 비즈니스 목표에 초점을 맞추고 DB 서버, 복제 또는 백업을 구성하는 데 시간을 소비하지 않습니다. 이러한 관심사 분리가 항상 고객에게 가장 유익한 것은 아니며 아예 불가능할 수도 있습니다. 그러나 관련이 있는 경우 소수의 엔지니어만으로 성공하고 널리 사용되는 응용 프로그램을 구축할 수 있습니다.

다른 사용 사례 중에서 매월 5천만 명이 넘는 사람들이 애플리케이션을 사용하는 Foursquare는 주로 AWS 기술 스택, 즉 클라우드 호스팅을 위한 Amazon EC2, 이미지 및 기타 데이터 저장을 위한 Amazon S3, 데이터 베이스.
가장 잘 알려진 클라우드 네이티브 데이터 스토리지 및 DB 서비스는 다음과 같습니다.

- AWS S3는 웹 서비스 인터페이스(REST API 또는 AWS SDK)를 통해 키-값 스토리지를 제공합니다. 이것은 파일, 이미지, 백업 또는 바이트 버킷으로 표시될 수 있는 기타 정보를 저장하도록 설계되었습니다.

- AWS DynamoDB 는 여러 데이터 센터에서 동기식 복제를 제공하는 완전 관리형 독점 NoSQL DB입니다.

- AWS Redshift는 병렬 처리(MPP) 기술을 기반으로 구축된 데이터 웨어하우스입니다. 이를 통해 빅 데이터에 대한 분석 워크로드가 가능합니다.

- Heroku PostgreSQL as a Service는 Heroku 클라우드 공급자가 완전히 관리하는 PostgreSQL DB로, Heroku 클러스터에 배포된 애플리케이션을 위한 공유 및 독점 DB 서버를 허용합니다.

- Google Cloud SQL은 Google에서 제공하는 완전 관리형 PostgreSQL 및 MySQL DB입니다.

- Google BigTable은 일관되게 짧은 지연 시간과 높은 처리량으로 대규모 워크로드를 처리하도록 설계된 압축된 고성능 독점 데이터 스토리지입니다.

- Azure Cosmos DB는 MongoDB 드라이버 수준 프로토콜 지원을 포함하여 몇 가지 다른 API가 있는 Microsoft의 독점적인 전 세계적으로 분산된 다중 모델 DB입니다.


## 마이크로서비스 간에 데이터 공유

실제 비즈니스 시스템에서는 클라이언트 요청을 처리하기 위해 둘 이상의 서비스가 소유한 데이터를 쿼리해야 하는 경우가 많습니다. 예를 들어, 클라이언트는 모든 주문과 주문에 해당하는 지불 상태를 보고 싶어할 수 있습니다. 마이크로서비스 아키텍처 이전에는 단일 조인 쿼리로 이를 구현할 수 있었지만 이제는 모범 사례에 위배됩니다. 다중 서비스 요청을 처리하려면 주문 및 결제 서비스를 모두 쿼리하고 필요한 모든 변환을 적용하고 집계된 결과를 클라이언트에 반환하는 어댑터 서비스를 구현해야 합니다. 또한 두 서비스가 통신을 많이 하거나 서로 의존도가 높으면 하나의 서비스로 병합하기에 적합한 후보가 될 수 있습니다(이러한 서비스 병합이 도메인 기반 설계에 해를 끼치지 않는 경우). 

다음 다이어그램은 이를 설명합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/9fac32cc-5c20-491e-8d64-f2b774a890a6.png)

다이어그램 7.8 주문 서비스 및 지불 서비스에서 데이터를 집계하는 어댑터 서비스

읽기 전략은 매우 간단하지만 한 번에 몇 가지 서비스가 필요한 전략을 구현하고 업데이트하는 것은 훨씬 어렵습니다. 고객이 주문을 하고 싶지만 적절한 재고 잔고와 지불 정보를 확인하는 것만 가능하다고 가정해 보겠습니다. 모든 서비스에는 자체 데이터베이스가 있으므로 워크플로우 내에서 둘 이상의 마이크로서비스와 데이터베이스가 비즈니스 트랜잭션에 포함됩니다. 이러한 문제를 해결하기 위한 몇 가지 접근 방식이 있지만 분산 트랜잭션과 이벤트 기반 아키텍처를 주로 사용합니다.

### 분산 트랜잭션

분산 트랜잭션은 연결된 둘 이상의 컴퓨터 시스템에서 데이터를 업데이트하는 트랜잭션입니다. 다시 말해서, 몇 개의 서비스가 한마음으로 모여서 어떤 행동이 일어났는지 아닌지에 동의합니다. 실제로 대부분의 데이터베이스 시스템은 글로벌 직렬화 가능성을 보장하기 위해 강력하고 엄격한 2단계 잠금을 사용합니다.

분산 트랜잭션은 종종 서비스에서 데이터 저장소를 원자적으로 업데이트하는 데 사용됩니다. 이들은 서로 다른 데이터 저장소에서 안정적인 작업을 보장하기 위해 모놀리식 애플리케이션에서 자주 사용되었습니다. 이는 동시에 장애로부터 적절한 복구를 용이하게 했습니다. 

그러나 오늘날 여러 마이크로서비스 간에 분산 트랜잭션을 사용하는 것은 권장되지 않습니다. 
여기에는 가장 중요한 이유는 다음과 같습니다.

- 분산 트랜잭션을 허용하는 서비스에는 2단계 커밋을 지원하는 API가 필요하며 구현이 간단하지 않습니다.
- 분산 트랜잭션과 관련된 마이크로서비스는 밀접하게 결합되어 있으며 이는 마이크로서비스 아키텍처에서 항상 권장되지 않습니다.
- 분산 트랜잭션은 확장되지 않으므로 시스템 대역폭이 제한되고 결과적으로 시스템 확장성이 감소합니다.

### 이벤트 중심 아키텍처

마이크로서비스 환경에서 분산 비즈니스 트랜잭션을 구현하는 가장 좋은 방법은 지금까지 이 책을 통해 몇 번 탐구한 이벤트 중심 아키텍처를 사용하는 것입니다.

시스템의 상태를 변경해야 하는 경우 첫 번째 서비스는 자체 데이터베이스의 데이터를 변경하고 동일한 내부 트랜잭션이 이벤트를 메시지 브로커에 게시합니다. 따라서 트랜잭션이 관련되어 있어도 서비스의 경계를 넘지 않습니다. 필요한 유형의 이벤트에 대한 구독을 등록하는 두 번째 서비스는 이벤트를 수신하고 그에 따라 저장소를 변경하고 이벤트를 보낼 수도 있습니다. 서비스는 함께 차단되지 않으며 서로 의존하지 않습니다. 시스템에 존재하는 유일한 결합은 그들이 교환하는 메시지에 있습니다. 

이와 대조적으로 분산 트랜잭션의 경우 이벤트 기반 아키텍처를 사용하면 첫 번째 서비스가 작동하는 시점에 두 번째 서비스가 실행되고 있지 않더라도 시스템이 진행될 수 있습니다. 이 특성은 시스템의 복원력에 직접적인 영향을 미치기 때문에 매우 중요합니다. 분산 트랜잭션은 모든 관련 구성 요소(마이크로서비스)를 사용할 수 있어야 하고 트랜잭션이 진행되는 전체 기간 동안 올바르게 작동해야 합니다. 시스템에 더 많은 마이크로서비스가 있거나 분산 트랜잭션 중에 마이크로서비스가 더 광범위하게 관여할수록 시스템이 진행되기가 더 어려워집니다.

이전과 같은 방식으로 두 서비스가 수다스러운 방식으로 많이 통신하는 경우 병합을 고려할 수 있습니다. 또한 몇 가지 서비스를 여러 번 업데이트하는 어댑터 서비스는 이벤트를 사용하여 구현할 수 있습니다.

### 최종 일관성

잠시 되돌아보고 소프트웨어 시스템에서 분산 트랜잭션이 수행하는 기능을 분석해 보겠습니다. 시스템 상태를 확인하기 위해 분산 트랜잭션을 사용한다는 것은 분명합니다. 즉, 시스템 전체의 일부 상태가 일치하지 않을 수 있다는 불확실성을 제거합니다. 그러나 이러한 불확실성의 제거는 매우 제한적인 요구입니다. 도메인 주도 설계 구현의 저자인 Vaughn Vernon은 불확실성을 도메인 모델에 포함할 것을 제안합니다. 그에 따르면 일관성 없는 상태로부터 시스템을 보호하기 어렵고 우리가 아무리 열심히 싸워도 일관성이 유지되지 않는다면 불확실성을 받아들이고 정규 비즈니스 워크플로의 일부로 포함시키는 것이 유리할 수 있습니다.

예를 들어, 당사 시스템은 결제 정보 확인이라는 새로운 상태를 도입하여 확인된 결제 정보 없이 주문을 생성할 수 있습니다. 이 새로운 이벤트는 불확실한 상황(지불 정보가 유효하거나 유효하지 않을 수 있음)을 유한한 시간 동안(지불 정보가 검증될 때까지) 차지할 수 있는 별도의 비즈니스 단계로 변환합니다. 이 접근 방식을 사용하면 시스템이 항상 일관적일 필요가 없습니다. 대신 시스템이 각 비즈니스 트랜잭션의 상태에 대한 일관된 비전을 갖도록 해야 합니다. 이러한 미래 일관성을 최종 일관성이라고 합니다. 다음 다이어그램은 이를 설명합니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/3388741e-71c9-4def-a9ae-1ee1c86aa481.png)

다이어그램 7.9 주문 및 지불 서비스는 모두 각자의 데이터베이스를 업데이트하고 메시지를 통해 워크플로 상태를 전달합니다.

일반적으로 최종 일관성 보장은 작동을 성공적으로 진행하는 적정한 시스템을 구축하기에 충분합니다. 또한 모든 분산 시스템은 사용 가능(사용자 요청 처리)하고 파티션 허용(구성 요소 간의 네트워크 중단에서 살아남기)을 위해 최종 일관성을 처리해야 합니다.


### SAGA 패턴

특히 마이크로서비스 세계에서 분산 트랜잭션에 가장 널리 사용되는 패턴 중 하나는 SAGA 패턴이라고 합니다. 이것은 데이터베이스에서 수명이 긴 트랜잭션을 관리하기 위해 1987년에 도입되었습니다.

SAGA는 몇 개의 작은 트랜잭션으로 구성되며 각 트랜잭션은 마이크로서비스에 로컬입니다. 여기에서 외부 요청은 saga을 시작하고 차례로 첫 번째 작은 트랜잭션을 시작하고 성공적으로 완료되면 두 번째 트랜잭션을 트리거하는 식입니다. 트랜잭션이 중간에 성공하지 못하면 이전 트랜잭션에 대한 보상 조치를 트리거합니다. 패턴을 구현하는 두 가지 주요 방법은 이벤트 기반 안무와 코디네이터 서비스를 통한 오케스트레이션입니다.

### 이벤트 소싱 패턴

마이크로서비스 애플리케이션을 통해 흐르는 이벤트를 처리하기 위해 마이크로서비스는 이벤트 소싱 패턴을 사용할 수 있습니다. 이벤트 소싱은 비즈니스 엔터티의 상태를 일련의 상태 변경 이벤트로 유지합니다. 
예를 들어, 은행 계좌는 초기 금액과 입금/출금 작업의 순서로 나타낼 수 있습니다. 이 정보가 있으면 업데이트 이벤트를 재생하여 현재 계정 상태를 계산할 수 있을 뿐만 아니라 엔터티 변경 사항에 대한 신뢰할 수 있는 감사 로그를 제공하고 쿼리가 과거의 어느 시점에서든 엔터티의 상태를 결정할 수 있습니다. 

일반적으로 이벤트 소싱을 구현하는 서비스는 다른 서비스가 엔터티 업데이트를 구독할 수 있도록 하는 API를 제공합니다.

현재 상태를 계산하는 데 필요한 시간을 최적화하기 위해 애플리케이션은 주기적으로 스냅샷을 빌드하고 저장할 수 있습니다. 저장 용량을 줄이기 위해 선택한 스냅샷 이전의 이벤트가 삭제될 수 있습니다. 이 경우 업데이트된 이벤트의 전체 기록 중 일부가 손실된 것이 분명합니다.
```
은행 계좌 111-11 이벤트 로그:

날짜 조치 금액
2018-06-04 22:00:01 $0 생성
2018-06-05 00:05:00 보증금 $50
2018-06-05 09:30:00 $10 출금
2018-06-05 14:00:30 예치금 $20
2018-06-06 15:00:30 보증금 $115
2018-06-07 10:10:00 $40 출금
 
현재 잔액: $135
```
단순함에도 불구하고 이벤트 소싱은 익숙하지 않고 약간 생소한 프로그래밍 접근 방식과 학습 곡선으로 인해 자주 사용되지 않습니다. 또한 상수 상태 재계산으로 인해 이벤트 소싱은 특히 쿼리가 복잡한 경우 효율적인 쿼리를 허용하지 않습니다. 이 경우 명령 쿼리 책임 분리가 도움이 될 수 있습니다.

### 명령 쿼리 책임 분리 패턴 CQRS

CQRS는 종종 이벤트 소싱과 함께 사용됩니다. CQRS는 두 부분으로 구성됩니다.

- 쓰기 부분은 상태 업데이트 명령을 수신하고 기본 이벤트 저장소에 저장하지만 엔터티 상태를 반환하지 않습니다.
- 읽기 부분은 상태를 변경하지 않고 요청된 쿼리 유형에 대해 상태를 반환합니다. 개별 쿼리에 대한 상태 표현은 업데이트 이벤트가 명령으로 수신된 후 비동기적으로 다시 계산되는 뷰에 저장됩니다.

CQRS 패턴이 작동하는 방식은 다음과 같습니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/60224e4e-4e7e-4011-886c-b8e80e6753b5.png)

다이어그램 7.10 주문 서비스에 대한 CQRS 구현. 쓰기 부분은 업데이트 명령을 저장하고 읽기 부분은 예상 쿼리에 대한 뷰를 비동기적으로 계산합니다.

CQRS 패턴은 소프트웨어 시스템이 방대한 양의 데이터를 스트리밍 방식으로 처리할 수 있도록 하는 동시에 현재 시스템 상태에 대한 다양한 쿼리에 신속하게 응답할 수 있도록 합니다.

### 충돌 없는 복제 데이터 타입 CRDT

애플리케이션이 커질수록 범위가 잘 정의된 단일 마이크로서비스의 경우에도 더 많은 데이터를 처리해야 합니다. 이전에 언급했듯이 트랜잭션은 잘 확장되지 않으며 애플리케이션이 성장함에 따라 하나의 마이크로 서비스 경계 내에서도 전역 상태를 일관되게 유지하기가 더 어렵습니다. 따라서 성능 및 시스템 확장성을 위해 전역 잠금 또는 트랜잭션 일관성 없이 다른 서비스 인스턴스에서 데이터를 동시에 업데이트할 수 있습니다. 이러한 접근 방식을 **낙관적 복제**라고 하며 나중에 해결해야 하는 불일치 가능성과 함께 데이터 복제본을 발전시킬 수 있습니다. 이러한 시나리오에서는 복제본이 병합될 때 복제본 간의 일관성이 다시 설정됩니다. 이 시점에서 충돌을 해결해야 하지만 이는 일반적으로 일부 변경 사항을 되돌려야 한다는 것을 의미하며, 이는 사용자의 관점에서 수용할 수 없을 수 있습니다. 그러나 병합 프로세스가 항상 성공하도록 보장하는 수학적 속성을 가진 데이터 구조도 있습니다. 이러한 데이터 구조를 CRDT라고 합니다.

CRDT는 여러 계산 단위에 걸쳐 복제될 수 있고, 조정 없이 동시에 업데이트되고, 일관된 상태를 얻기 위해 병합될 수 있는 데이터 유형을 설명합니다. 이 개념은 2011년 Marc Shapiro, Nuno Preguica, Marek Zawirski 및 Carlos Baquero에 의해 설명되었습니다. 작성 당시 CRDT에는 Grow-only Counter, Grow-only Set, a Two와 같은 소수의 데이터 유형이 있습니다. -Phase Set, Last-Write-Wins-Element Set 및 일반적인 비즈니스 워크플로의 하위 집합만 다룰 수 있는 몇 가지 다른 집합입니다. 그러나 CRDT는 협업 텍스트 편집, 온라인 채팅 및 온라인 도박에 여전히 매우 유용한 것으로 입증되었습니다. SoundCloud 오디오 배포 플랫폼은 CRDT를 사용하고 Phoenix 웹 프레임워크는 CRDT를 사용하여 실시간 다중 노드 정보 공유를 가능하게 하는 반면 Microsoft의 Cosmos DB는 다중 마스터 데이터 작성을 위해 CRDT를 사용합니다. Redis 데이터베이스에는 CRDB(Conflict-Free Replicated Database) 형식의 CRDT 지원 기능이 내장되어 있습니다.

### 데이터 저장소로서의 메시징 시스템

이벤트 소싱이라는 아이디어를 바탕으로 메시지에 대한 지속성 저장소가 있는 메시지 브로커가 개별 마이크로서비스를 위한 전용 데이터베이스의 필요성을 줄일 수 있다는 결론을 내릴 수 있습니다. 실제로 모든 엔티티 업데이트 이벤트(엔티티 스냅샷 포함)가 충분한 시간 동안 메시지 브로커에 저장되고 언제든지 다시 읽을 수 있는 경우 시스템의 전체 상태는 해당 이벤트에 의해서만 정의될 수 있습니다. 시작하는 동안 각 서비스는 최근 이벤트 기록(마지막 스냅샷까지)을 읽고 메모리에서 엔터티의 상태를 다시 계산할 수 있습니다. 따라서 서비스는 단순히 새로운 업데이트 명령을 처리하고 쿼리를 읽고, 때때로 엔티티 스냅샷을 생성하여 브로커에 보내는 것으로 작동할 수 있습니다.

Apache Kafka는 시스템의 기본 데이터 저장소이자 잠재적으로 유일한 데이터 저장소로 사용할 수 있는 안정적인 지속성 계층이 있는 널리 사용되는 분산 메시지 브로커입니다.

우리가 볼 수 있듯이, 오늘날 다중 언어 지속성 및 메시지 브로커를 기반으로 하는 이벤트 중심 아키텍처는 종종 함께 사용되어 변동성이 크고 확장 가능하며 끊임없이 변화하는 소프트웨어 시스템에서 안정적이고 복잡한 워크플로를 구현합니다. 나머지 장의 나머지 부분은 Spring Framework에서 제공하는 지속성 메커니즘에 중점을 두고 있으며, 8장, Scaling Up with Cloud Streams에서는 이벤트 기반 아키텍처를 기반으로 효율적인 애플리케이션을 구현하기 위해 Spring 에코시스템에서 사용할 수 있는 기술을 보여줍니다.



## 데이터 검색을 위한 동기 모델

반응형 퍼시스턴시의 모든 이점과 단점을 이해하려면 먼저 반응형 시대 이전의 애플리케이션이 데이터 액세스를 구현한 방법을 요약해야 합니다. 또한 쿼리를 실행하고 처리할 때 클라이언트와 데이터베이스가 통신하는 방법, 이러한 통신의 어떤 부분을 비동기적으로 수행할 수 있는지, 반응 프로그래밍 패턴을 적용하면 어떤 부분이 이점을 얻을 수 있는지 배워야 합니다. 데이터베이스 지속성은 몇 가지 추상 레이어로 구성되어 있으므로 이 모든 레이어를 살펴보고 설명하고 반응형으로 시도합니다.

### 데이터베이스 액세스를 위한 통신 프로토콜

임베디드 데이터베이스라고 하는 데이터베이스 유형이 있습니다. 이러한 데이터베이스는 응용 프로그램 프로세스 자체 내에서 실행되며 네트워크를 통한 통신이 필요하지 않습니다. 임베디드 데이터베이스의 경우 일부는 임베디드 모드나 별도의 서비스로 둘 다 가지고 있거나 실행할 수 있지만 유선 프로토콜이 있어야 한다는 어려운 요구 사항은 없습니다. 이 장의 뒷부분에서 몇 가지 예에서 H2 내장 데이터베이스를 사용할 것입니다.

그러나 대부분의 소프트웨어는 별도의 서버(또는 별도의 컨테이너)에서 별도의 프로세스에서 실행되는 데이터베이스를 사용합니다. 응용 프로그램은 데이터베이스 드라이버라는 특수 클라이언트 라이브러리를 사용하여 외부 데이터베이스와 통신합니다. 또한 유선 프로토콜은 데이터베이스 드라이버와 데이터베이스 자체가 통신하는 방법을 정의합니다. 클라이언트와 데이터베이스 간에 전송되는 메시지 순서의 형식을 정의합니다. 대부분의 경우 유선 프로토콜은 언어 독립적이므로 Java 애플리케이션이 C++로 작성된 데이터베이스를 쿼리할 수 있습니다.

통신 프로토콜은 일반적으로 TCP/IP를 통해 작동하도록 설계되었으므로 통신 프로토콜을 차단할 필요가 없습니다. 동기 HTTP 통신과 마찬가지로 프로토콜 자체가 차단되지 않으며 결과를 기다리는 동안 차단을 결정하는 것은 클라이언트입니다. 또한 TCP는 슬라이딩 창에 의해 구현된 흐름 제어를 통해 역압을 지원하는 비동기 프로토콜입니다. 그러나 슬라이딩 윈도우 접근 방식은 네트워크를 통해 바이트 청크를 전송하도록 조정되었으며 응용 프로그램의 백프레셔 요구 사항을 최상의 방식으로 반영하지 못할 수 있습니다. 예를 들어 데이터베이스에서 행을 수신할 때 네트워크 버퍼 크기를 정의하는 시스템 설정에 의존하는 것보다 행 수로 데이터 처리의 다음 부분을 요청하는 것이 더 자연스럽습니다. 물론 유선 프로토콜은 의도적으로 다른 메커니즘을 사용하거나 역압 구현을 위한 메커니즘의 조합을 사용할 수도 있지만 TCP 메커니즘도 항상 내부에서 작동한다는 점을 기억하는 것이 중요합니다.

데이터베이스 통신 프로토콜의 기반으로 더 높은 수준의 프로토콜을 사용하는 것도 가능합니다. 
예를 들어 HTTP2, WebSocket, gRPC 또는 RSocket을 사용할 수 있습니다. 8장, Cloud Streams를 사용한 확장에서는 RSocket 및 gRPC 프로토콜을 간략하게 비교합니다.

역압 문제 외에도 클라이언트와 데이터베이스 간에 큰 데이터 세트를 통신하기 위한 다양한 접근 방식이 있습니다. 예를 들어 클라이언트가 수만 개의 데이터 행을 삽입하거나 분석 쿼리 결과에 수백만 개의 행이 포함됩니다. 단순함을 위해 후자의 사용 사례만 고려하겠습니다. 일반적으로 이러한 결과 집합을 전달하기 위한 몇 가지 접근 방식이 있습니다.

- 데이터베이스 측에서 전체 결과 집합을 계산하여 데이터를 컨테이너에 넣고 쿼리가 완료되는 즉시 컨테이너를 완전히 보냅니다. 이 접근 방식은 논리적 백프레셔를 의미하지 않으며 데이터베이스 측(및 잠재적으로 클라이언트 측)에 거대한 버퍼가 필요합니다. 또한 클라이언트는 전체 쿼리가 실행된 후에야 첫 번째 결과를 받습니다. 이러한 접근 방식은 구현하기 쉽습니다. 또한 쿼리 실행 프로세스가 너무 오래 지속되지 않으며 업데이트된 쿼리가 동시에 발생하여 경합이 덜 발생할 수 있습니다.

- 클라이언트가 요청할 때 결과 집합을 청크로 보냅니다. 쿼리는 완전히 실행될 수 있으며 결과는 버퍼에 저장될 수 있습니다. 또는 데이터베이스는 요청된 청크 하나 또는 몇 개를 채우고 클라이언트의 요구를 전달한 후에만 실행을 계속하는 지점까지만 쿼리를 실행할 수 있습니다. 이러한 작동 방식은 더 적은 수의 메모리 버퍼를 필요로 할 수 있으며 쿼리가 여전히 실행 중일 때 첫 번째 행을 반환하고 논리적 백프레셔 또는 쿼리 취소를 전파하는 것을 가능하게 합니다.

- 쿼리 실행 중에 이러한 결과를 얻는 즉시 결과를 스트림으로 보냅니다. 뿐만 아니라 클라이언트는 수요에 대해 데이터베이스에 알리고 쿼리 실행 프로세스에 영향을 줄 수 있는 논리적 백프레셔를 전파할 수도 있습니다. 이러한 접근 방식은 추가 버퍼가 거의 필요하지 않으며 클라이언트는 가능한 한 빨리 결과의 첫 번째 행을 수신합니다. 그러나 이러한 통신 방식은 매우 수다스러운 통신 방식과 빈번한 시스템 호출로 인해 네트워크와 CPU를 충분히 활용하지 않을 수 있습니다.

다음 다이어그램은 청크 결과 흐름에 대한 상호 작용 흐름을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/35c191a1-15fa-4a36-b56d-36801fe2ae3b.png)

다이어그램 7.11 청크를 사용한 쿼리 결과 반복

일반적으로 서로 다른 데이터베이스는 통신 프로토콜에서 하나 이상의 접근 방식을 구현합니다. 예를 들어, MySQL은 데이터를 전체 또는 스트림으로 행 단위로 보내는 방법을 알고 있습니다. 동시에 PostgreSQL 데이터베이스에는 포털이라는 개념이 있어 클라이언트가 수신할 준비가 된 만큼의 데이터 행을 전파할 수 있습니다. 앞의 다이어그램은 Java 애플리케이션이 이러한 접근 방식을 사용하는 방법을 보여줍니다.

이 수준에서 잘 설계된 데이터베이스 통신 프로토콜은 반응형에 필요한 모든 특성을 이미 갖추고 있을 수 있습니다.

### 데이터베이스 드라이버

데이터베이스 드라이버는 메서드 호출, 콜백 또는 잠재적인 Reactive Streams와 같은 언어 구성에 데이터베이스 유선 프로토콜을 적용하는 라이브러리입니다. 관계형 데이터베이스의 경우 드라이버는 일반적으로 Python용 DB-API 또는 Java용 JDBC와 같은 언어 수준 API를 구현합니다.

동기 차단 방식으로 작성된 소프트웨어가 데이터 액세스에 대해 동일한 접근 방식을 사용한다는 것은 놀라운 일이 아닙니다. 또한 일반적으로 드라이버를 통한 외부 데이터베이스와의 통신은 외부 HTTP 서비스와의 통신과 다르지 않습니다. 예를 들어 Apache Phoenix JDBC 드라이버는 Apache Calcite 프레임워크의 Avatica 구성 요소를 기반으로 하며 HTTP를 통한 JSON 또는 프로토콜 버퍼를 사용합니다. 결과적으로 이론적으로 우리는 데이터베이스 통신 프로토콜에 반응형 디자인을 적용할 수 있으며 Spring WebFlux 모듈의 반응형 WebClient와 매우 유사한 이점을 얻을 수 있습니다. 다음 다이어그램은 HTTP 요청과 데이터베이스 쿼리가 네트워크 통신 관점에서 매우 유사함을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/0c883f62-dc55-4039-92fd-d31edbbdaef5.png)

그림 7.12 차단 HTTP 요청과 데이터베이스 요청의 유사한 차단 IO 동작

일반적으로 데이터베이스 드라이버의 차단 특성은 유선 프로토콜이 아니라 상위 수준 API에 의해 결정됩니다. 결과적으로 적절한 언어 수준 API가 있는 반응형 데이터베이스 드라이버를 구현하는 것은 어렵지 않아야 합니다. 이러한 API의 후보는 이 장의 뒷부분에서 다룹니다. 동시에 NoSQL 데이터베이스 드라이버는 구현해야 할 언어 수준 API가 설정되어 있지 않으므로 자체 API를 비동기식으로 또는 사후적으로 자유롭게 구현할 수 있습니다. 예를 들어 MongoDB, Cassandra 및 Couchbase는 이 경로를 사용하기로 결정했으며 이제 비동기 또는 반응형 드라이버를 제공합니다.

### JDBC
1997년에 처음으로 출시된 JDBC(Java Database Connectivity)는 애플리케이션이 데이터베이스와 통신하는 방법(기본 관계형)을 정의하여 Java 플랫폼에서 데이터 액세스를 위한 통합 API를 제공합니다. 최신 API 개정판인 4.3은 2017년에 릴리스되었으며 Java SE 9에 포함되었습니다.

JDBC를 사용하면 여러 데이터베이스 클라이언트 드라이버가 존재하고 동일한 응용 프로그램에서 사용할 수 있습니다. JDBC 드라이버 관리자는 필요한 드라이버 구현의 올바른 등록, 로드 및 사용을 담당합니다. 드라이버가 로드되면 클라이언트는 적절한 액세스 자격 증명을 사용하여 연결을 만들 수 있습니다. JDBC 연결을 통해 SQL의 SELECT, CREATE, INSERT, UPDATE 및 DELETE와 같은 명령문을 초기화하고 실행할 수 있습니다. 데이터베이스의 상태를 실행 결과로 업데이트하는 명령문은 영향을 받는 여러 행을 반환하고 쿼리 명령문은 결과 행에 대한 반복자인 java.sql.ResultSet을 반환합니다. ResultSet은 오래 전에 설계되었으며 이상한 API를 가지고 있습니다. 예를 들어, 행의 열을 열거하는 인덱스는 0이 아니라 1부터 시작합니다.

ResultSet 인터페이스는 역방향 반복 및 임의 액세스를 위해 설계되었지만 해당 수준의 호환성을 위해서는 드라이버가 처리를 허용하기 전에 모든 행을 로드해야 합니다. 단순함을 위해 ResultSet이 결과 행에 대한 단순 반복자와 유사하다고 가정합니다. 이 가정을 통해 기본 구현이 청크된 결과 집합에 대해 작동하고 요청 시 데이터베이스에서 일괄 처리를 로드할 수 있습니다. 기본 비동기 구현은 JDBC 수준에서 동기 차단 호출로 래핑되어야 합니다.

성능 영역에서 JDBC는 비선택 쿼리에 대한 일괄 처리를 허용합니다. 이렇게 하면 더 적은 수의 네트워크 요청으로 데이터베이스와 통신할 수 있습니다. 그러나 JDBC는 동기 및 차단으로 설계되었기 때문에 큰 데이터 세트를 처리할 때 도움이 되지 않습니다.

JDBC는 비즈니스 로직 레벨 API로 설계되었지만 도메인 주도 설계에서 권장하는 엔티티 및 집계 대신 테이블, 행 및 열로 작동합니다. 따라서 오늘날 JDBC는 직접 사용하기에는 너무 낮은 수준으로 간주됩니다. 이러한 목적을 위해 Spring 생태계에는 Spring Data JDBC 및 Spring Data JPA 모듈이 있습니다. 또한 JDBC를 래핑하고 사용하기에 더 쾌적한 API를 제공하는 잘 정립된 라이브러리가 많이 있습니다. 그러한 라이브러리의 한 예는 Jdbi입니다. 유창한 API를 제안할 뿐만 아니라 Spring 생태계와의 뛰어난 통합성을 제공합니다.

### 연결 관리
최신 애플리케이션은 JDBC 연결을 직접 생성하는 경우가 거의 없고 연결 풀이 사용됩니다. 그 이유는 매우 간단합니다. 새 연결을 설정하는 데 비용이 많이 듭니다. 따라서 재사용을 허용하는 방식으로 연결 캐시를 관리하는 것이 좋습니다. 연결 생성 비용은 두 가지 영역에서 발생할 수 있습니다. 먼저 연결 시작 과정에서 클라이언트 인증과 권한 부여가 필요할 수 있으며, 이는 귀중한 시간이 소요됩니다. 둘째, 새로운 연결은 데이터베이스에 막대한 비용이 들 수 있습니다. 예를 들어, PostgreSQL은 새로운 연결이 설정될 때마다 완전히 새로운 프로세스(스레드가 아님!)를 생성하며, 강력한 Linux 시스템에서는 자체적으로 수백 밀리초가 소요될 수 있습니다. 작성 당시 Java 플랫폼에서 가장 일반적으로 사용되는 연결 풀은 Apache Commons DBCP2, C3P0, Tomcat JDBC 및 HikariCP입니다. HikariCP는 Java 세계에서 가장 빠른 연결 풀로 간주됩니다.

연결 풀링은 JDBC 연결에 널리 사용되지만 데이터베이스 통신의 고유한 부분은 아닙니다. 예를 들어, Oracle 데이터베이스 드라이버는 연결 다중화를 허용하므로 단일 네트워크 연결을 통해 여러 논리적 연결을 퍼널링할 수 있습니다. 물론 이러한 지원은 드라이버뿐만 아니라 유선 프로토콜 및 데이터베이스 구현 자체에 의해 활성화됩니다.


## 관계형 데이터베이스 액세스를 반응형으로 만들기

JDBC는 Java 세계에서 데이터 액세스를 위한 기본 언어 수준 API이므로(적어도 관계형 데이터 소스의 경우) JDBC는 그 위에 구축된 모든 추상화 수준의 동작을 형성합니다. 이전에 차단 API는 응용 프로그램의 확장성을 제한하므로 반응형 응용 프로그램에서 사용하지 않는 것이 좋습니다. 결과적으로 반응형 애플리케이션에서 사용할 적절한 언어 수준 데이터베이스 액세스 API를 갖는 것이 중요합니다. 불행히도 그러한 목적을 위해 JDBC를 약간 조정할 수 있는 쉬운 솔루션은 없습니다. 현재 두 개의 유망한 API 초안이 이 틈새 시장에 적합할 수 있으며 이 장의 뒷부분에서 살펴보겠습니다. 다음 다이어그램은 반응형 JDBC API를 만드는 데 필요한 사항을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/8085232b-5ac2-489d-b676-5a9dc2125131.png)

다이어그램 7.13 현재 JDBC 스택과 잠재적인 반응적 교체 관계형 데이터베이스 액세스를 반응형으로 만들기

# Spring JDBC

원시 JDBC를 둘러싼 번거로움을 단순화하기 위해 Spring은 꽤 오래되었지만 잘 설명된 Spring JDBC 모듈을 제공합니다. 이 모듈은 쿼리를 실행하고 관계형 행을 엔터티에 매핑하는 데 도움이 되는 `JdbcTemplate` 클래스의 몇 가지 버전을 제공합니다. 또한 리소스 생성 및 해제를 처리하여 준비된 명령문 또는 연결을 닫는 것을 잊어버리는 것과 같은 일반적인 오류를 생략하는 데 도움이 됩니다. JdbcTemplate은 또한 JDBC 예외를 포착하여 일반 org.springframework.dao 예외로 변환합니다.

SQL 데이터베이스에 Book 모음이 있고 엔티티가 다음 Java 클래스로 표시된다고 가정해 보겠습니다.
```java
class Book {
   private int id;
   private String title;

   public Book() { }

   public Book(int id, String title) {
      this.id = id;
      this.title = title;
   }
   //getters and setters ...
}
```
With JdbcTemplate and a generic BeanPropertyRowMapper, we may create a Spring repository in the following way:

```java
@Repository
class BookJdbcRepository {

   @Autowired
   JdbcTemplate jdbcTemplate;

   public Book findById(int id) {
      return jdbcTemplate.queryForObject(
         "SELECT * FROM book WHERE id=?",
         new Object[] { id },
         new BeanPropertyRowMapper<>(Book.class));
   }
}
```
Alternatively, we may provide our own mapper class to instruct Spring on how a  ResultSet should be translated into a domain entity:
```java
class BookMapper implements RowMapper<Book> {
    @Override
    public Book mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Book(rs.getInt("id"), rs.getString("title"));
    }
}
```
Let's implement the BookJdbcRepository.findAll() method using the BookMapper class:
```java
public List<Book> findAll() {
    return jdbcTemplate.query("SELECT * FROM book", new BookMapper());
}
```
JdbcTemplate에 대한 또 하나의 개선 사항은 `NamedParameterJdbcTemplate` 클래스에 의해 구현됩니다. 결과적으로 준비된 SQL 쿼리와 해당 Java 코드는 다음과 같을 수 있습니다.

```sql
SELECT * FROM book WHERE title = :searchtitle
```
Here is a classic prepared SQL statement:
```sql
SELECT * FROM book WHERE title = ?
```
이것은 사소한 개선으로 보일 수 있지만 명명된 매개변수는 특히 쿼리에 6개의 매개변수가 필요한 경우 색인보다 코드 가독성이 더 좋습니다.

요약하면 Spring JDBC 모듈은 상위 수준 추상화에서 사용되는 유틸리티, 도우미 클래스 및 도구로 구성됩니다. 상위 수준 API는 Spring JDBC 모듈을 제한하지 않으므로 기본 API도 지원하므로 필요한 반응 지원을 비교적 쉽게 흡수할 수 있습니다.


### 스프링 데이터 JDBC

Spring Data JDBC는 Spring Data 패밀리의 아주 새로운 모듈입니다. JDBC 기반 저장소의 구현을 단순화하는 것을 목표로 합니다. JDBC 기반 저장소를 포함한 Spring Data 저장소는 Eric Evans의 Domain-Driven Design에 설명된 저장소에서 영감을 받았습니다. 즉, Aggregate Root당 저장소를 갖는 것이 좋습니다. Spring Data JDBC는 @Query 주석 및 엔티티 수명 주기 이벤트를 지원하는 간단한 집계를 위한 CRUD 작업을 제공합니다.

> 주의: Spring Data JDBC와 Spring JDBC는 다른 모듈입니다!

Spring Data JDBC를 사용하려면 Book 엔터티를 수정하고 `org.springframework.data.annotation.Id` 주석을 id 필드에 적용해야 합니다. 리포지토리에는 엔터티에 고유 식별자가 있어야 하므로 리포지토리에서 사용하기 위해 리팩토링된 Book 엔터티는 다음과 같습니다.

```java
class Book {
   @Id
   private int id;
   private String title;

   // other parts are unchanged
}
```
이제 `CrudRepository<Book, Integer>`에서 파생된 `BookRepository` 인터페이스를 정의해 보겠습니다.

```java
@Repository
public interface BookSpringDataJdbcRepository extends CrudRepository<Book, Integer> { // (1)
   
   @Query("SELECT * FROM book WHERE LENGTH(title) = (SELECT MAX(LENGTH(title)) FROM book)") // (2)
   List<Book> findByLongestTitle(); // (2.1)

   @Query("SELECT * FROM book WHERE LENGTH(title) = (SELECT MIN(LENGTH(title)) FROM book)")
   Stream<Book> findByShortestTitle(); // (3.1)

   @Async // (4)
   @Query("SELECT * FROM book b "WHERE b.title = :title")
   CompletableFuture<Book> findBookByTitleAsync( // (4.1)
      @Param("title") String title);

   @Async // (5)
   @Query("SELECT * FROM book b WHERE b.id > :fromId AND b.id < :toId")
   CompletableFuture<Stream<Book>> findBooksByIdBetweenAsync(      // (5.1)
      @Param("fromId") Integer from,
      @Param("toId") Integer to);
}
```
앞의 코드는 다음 작업을 수행합니다.

(1) CrudRepository를 확장하여 Book 저장소는 save(...), saveAll(...), findById(...), deleteAll()과 같은 기본 CRUD 작업을 위한 12가지 메서드를 받았습니다.

(2) @Query 주석에 정의된 사용자 정의 SQL을 제공하여 가장 긴 제목의 책을 ​​찾는 사용자 정의 메소드를 등록합니다. 그러나 Spring JDBC와 달리 ResultSet 변환이 표시되지 않습니다. JdbcTemplate은 필요하지 않으며 우리가 작성해야 하는 유일한 것은 인터페이스입니다. Spring Framework는 많은 함정을 처리하면서 구현을 생성합니다. `findByLongestTitle` 메서드(2.1)의 결과로 저장소는 List 컨테이너를 반환하므로 전체 쿼리 결과가 도착할 때만 클라이언트가 차단 해제됩니다.

(3.1) 또는 저장소가 책의 스트림을 반환할 수 있으므로 기본 구현에 따라 클라이언트가 `findByShortestTitle` 메서드(3.1)를 호출할 때 API는 데이터베이스가 여전히 쿼리를 실행하는 동안 첫 번째 요소를 처리하도록 허용할 수 있습니다. 물론 이것은 기본 구현과 데이터베이스 자체가 이 작동 모드를 지원하는 경우에만 해당됩니다.

(4.1) `findBookByTitleAsync` 메서드를 사용하여 저장소는 Spring Framework의 비동기 지원을 활용합니다. 이 메서드는 CompletableFuture를 반환하므로 결과를 기다리는 동안 클라이언트의 스레드가 차단되지 않습니다. 불행히도, 기본 스레드는 JDBC의 차단 방식으로 인해 여전히 잠겨 있어야 합니다.

(5.1) 또한 `findBooksByIdBetweenAsync` 메서드에서와 같이 CompletableFuture와 Stream을 결합할 수 있습니다. 그렇게 하면 첫 번째 행이 도착할 때까지 클라이언트의 스레드가 차단되어서는 안 되며 결과 집합이 청크로 순회될 수 있습니다. 불행히도 실행의 첫 번째 부분에서는 기본 스레드가 차단되어야 하며 클라이언트의 스레드는 나중에 다음 데이터 청크를 검색할 때 차단됩니다. 이러한 동작은 반응형 지원 없이 JDBC를 사용하여 달성할 수 있는 최선입니다.

Spring Data JDBC로 BookRepository 구현을 생성해야 할 필요성에 대해 Spring에 알리려면 Spring Boot 애플리케이션에 다음 종속성을 추가해야 합니다.
```gradle
compile('org.springframework.data:spring-data-jdbc:1.0.0.RELEASE')
```

애플리케이션 구성에 `@EnableJdbcRepositories` 주석을 추가하는 것도 필요합니다. 내부적으로 Spring Data JDBC는 이전에 논의된 Spring JDBC 및 `NamedParameterJdbcTemplate`을 사용합니다.

Spring Data JDBC는 소규모 마이크로서비스를 위한 간단한 지속성 계층을 구축하는 편리한 방법을 제공하는 아주 작은 모듈입니다. 그러나 의도적으로 단순하게 설계되었으며 캐싱, 엔터티의 지연 로드 및 복잡한 엔터티 관계와 같은 ORM 측면을 대상으로 하지 않습니다. 이러한 목적을 위해 Java 생태계에는 JPA(Java Persistence API)라는 별도의 사양이 있습니다.


## Spring Data JDBC를 반응형으로 만들기

Spring Data JDBC는 더 큰 프로젝트인 Spring Data Relational의 일부입니다. Spring Data JDBC는 완전 반응형 스택에 적합하지 않은 완전 차단 API인 JDBC를 필요로 합니다. 작성 시점에서 Spring Data 팀은 드라이버가 데이터베이스와 완전히 반응형이고 차단되지 않는 통합을 제공할 수 있도록 하는 R2DBC 사양을 개발합니다. 이러한 노력은 Spring Data Relational 프로젝트의 일부가 될 `Spring Data R2DBC` 모듈에 채택될 가능성이 높습니다. 다음 다이어그램은 Spring Data Relational의 잠재적인 반응 스택을 보여줍니다.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/4157c546-5f8a-4bbf-8a04-6ef7093cf491.png)

다이어그램 7.14 현재 Spring Data JDBC 스택과 잠재적인 반응형 교체

## JPA

JPA는 2006년에 처음 등장했으며(최신 버전인 2.2는 2013년에 릴리스되었으며 때로는 JPA2라고도 함) Java 응용 프로그램에서 관계형 데이터 관리를 설명하는 것을 목표로 합니다. 오늘날 JPA는 애플리케이션이 지속성 계층을 구성하는 방법을 정의하는 표준입니다. API 자체와 JPQL로 구성됩니다. JPQL은 데이터베이스 대신 리포지토리를 통해 JPA 엔터티 개체를 쿼리하는 SQL과 유사한 플랫폼 독립적 언어입니다.

데이터베이스 액세스 표준인 JDBC와 달리 JPA는 코드의 개체를 데이터베이스의 테이블에 매핑할 수 있는 ORM의 표준입니다. ORM은 일반적으로 내부에서 JDBC 및 비행 중 생성된 SQL 쿼리를 사용하지만 이 메커니즘은 대부분 애플리케이션 개발자에게 숨겨져 있습니다. JPA는 연관된 객체를 쉽게 로드하기 위해 엔티티뿐만 아니라 엔티티 관계도 매핑할 수 있습니다.

가장 많이 사용되는 JPA 구현은 Hibernate(http://hibernate.org) 및 EclipseLink(http://www.eclipse.org/eclipselink)입니다. 이 두 가지 모두 JPA 2.2를 구현하며 서로 바꿔 사용할 수 있습니다. JPA 표준을 구현하는 것 외에도 두 프로젝트 모두 사양에 정의되어 있지 않지만 경우에 따라 편리할 수 있는 추가 기능 세트를 제안합니다. 예를 들어, EclipseLink를 사용하면 데이터베이스 변경 이벤트를 처리하고 여러 데이터베이스의 테이블에 대한 엔터티 매핑을 설명할 수 있습니다. 반면에 Hibernate는 타임스탬프와 자연 ID에 대한 더 나은 지원을 제안합니다. 두 라이브러리 모두 다중 테넌시를 지원합니다. 그러나 독점 기능을 사용할 때 이러한 라이브러리는 더 이상 호환되지 않는다는 점을 이해해야 합니다.

순수 JDBC 대신 JPA 구현을 사용하는 또 다른 이유는 Hibernate와 EclipseLink에서 제공하는 캐싱 기능 때문입니다. 두 라이브러리 모두 첫 번째 수준 세션 캐시 또는 두 번째 수준 외부 캐시에서 엔터티를 캐싱하는 실제 데이터베이스 요청 수를 최소화할 수 있습니다. 이 기능만으로도 애플리케이션 성능에 상당한 영향을 미칠 수 있습니다.

### JPA를 반응형으로 만들기
작성 당시에는 JPA를 비동기식으로 만들려는 시도가 있었는지 반응적으로 만들려는 시도가 있었는지 알 수 없습니다. 그러한 작업에는 JPA도 구축된 JDBC에 대해 설정된 비동기 또는 반응 교체가 필요합니다. 또한 JPA는 반응형 프로그래밍에서 더 이상 사실이 아닌 많은 가정으로 설계되었습니다. 게다가 JPA 제공자의 방대한 코드 기반은 반응형 리팩토링의 쉬운 대상이 아닙니다. 결과적으로 빠른 시일 내에 반응형 JPA 지원이 없을 것입니다.

## 스프링 데이터 JPA

Spring Data JPA는 유사하게 Spring Data JDBC와 같은 저장소를 구축할 수 있도록 하지만 내부적으로는 훨씬 더 강력한 JPA 기반 구현을 사용합니다. Spring Data JPA는 Hibernate와 EclipseLink 모두를 훌륭하게 지원합니다. 즉석에서 Spring Data JPA는 메서드 이름 규칙을 기반으로 JPA 쿼리를 생성하여 Generic DAO 패턴에 대한 구현을 제공하고 안전한 Java 기반 쿼리 Querydsl 라이브러리(http://www.querydsl.com)에 대한 지원을 추가하여 우아한 형식을 가능하게 합니다.

이제 Spring Data JPA의 기본 사항을 보여주는 간단한 애플리케이션을 만들어 보겠습니다. 다음 종속성은 Spring Boot 애플리케이션에 필요한 모든 모듈을 가져옵니다.
```gradle
compile('org.springframework.boot:spring-boot-starter-data-jpa')
```
Spring Boot는 Spring Data JPA가 사용 중임을 추론할 만큼 충분히 똑똑하므로 `@EnableJpaRepositories` 주석을 추가할 필요조차 없습니다(그러나 원하는 경우 추가할 수 있음). Book 엔터티는 다음과 같아야 합니다.

```java
@Entity
@Table(name = "book")
public class Book {
   @Id
   private int id;
   private String title;

   // Constructors, getters, setters...
}
```
`javax.persistence.Entity` 주석으로 표시된 Book 엔티티를 사용하면 JPQL 쿼리에 사용되는 엔티티 이름을 설정할 수 있습니다. `@Table` 주석은 테이블을 정의하고 제약 조건과 인덱스도 정의할 수 있습니다. org.springframework.data.annotation.Id 주석 대신에 `javax.persistence.Id` 주석을 사용해야 한다는 점에 유의하는 것이 중요합니다.

이제 쿼리 생성에 이름 지정 규칙을 사용하는 사용자 지정 메서드와 JPQL 쿼리를 사용하는 다른 메서드를 사용하여 CRUD 저장소를 정의해 보겠습니다.

```java
@Repository
interface BookJpaRepository extends CrudRepository<Book, Integer> {

   Iterable<Book> findByIdBetween(int lower, int upper);

   @Query("SELECT b FROM Book b WHERE LENGTH(b.title) = " +
            "(SELECT MIN(LENGTH(b2.title)) FROM Book b2)")
   Iterable<Book> findShortestTitle();
}
```
클래스 경로의 JDBC 드라이버, 하나의 Spring Boot 종속성, Book 엔터티 클래스 및 BookJpaRepository 인터페이스는 다음 기술 스택(Spring Data JPA, JPA, JPQL, Hibernate, 그리고 JDBC) 기반에서 다채로운 지속성을 제공한다.

## Spring Data JPA를 반응형으로 만들기

불행히도 Spring Data JPA 모듈의 반응형 변형은 JDBC, JPA 및 JPA 공급자를 포함하여 모든 기본 계층도 반응형이어야 합니다. 따라서 앞으로 몇 년 동안 이런 일이 일어날 가능성은 거의 없습니다.


## Spring Data NoSQL

Spring Data JPA와 Spring Data JDBC는 둘 다 최소한 JDBC 드라이버를 제공하는 관계형 데이터베이스에 연결하기 위한 훌륭한 솔루션이지만 대부분의 NoSQL 데이터베이스는 이를 수행하지 않습니다. 이러한 경우 Spring Data 프로젝트에는 인기 있는 NoSQL 데이터베이스를 하나씩 대상으로 하는 두 개의 별도 모듈이 있습니다. Spring 팀은 MongoDB, Redis, Apache Cassandra, Apache Solr, Gemfire, Geode 및 LDAP용 모듈을 적극적으로 개발합니다. 동시에 커뮤니티는 Aerospike, ArangoDB, Couchbase, Azure Cosmos DB, DynamoDB, Elasticsearch, Neo4j, Google Cloud Spanner, Hazelcast 및 Vault와 같은 데이터베이스 및 스토리지용 모듈을 개발합니다.

EclipseLink와 Hibernate가 모두 NoSQL 데이터베이스를 지원한다는 점은 언급할 가치가 있습니다. 
- EclipseLink는 MongoDB, Oracle NoSQL, Cassandra, Google BigTable 및 Couch DB를 지원합니다. 다음 문서에서는 EclipseLink의 NoSQL 지원에 대해 설명합니다. https://wiki.eclipse.org/EclipseLink/Examples/JPA/NoSQL. 
- Hibernate에는 Infinispan, MongoDB, Neo4j 등과 같은 NoSQL 지원을 대상으로 하는 Hibernate OGM(http://hibernate.org/ogm)이라는 하위 프로젝트가 있습니다. 
 
그러나 JPA는 본질적으로 관계형 API이므로 이러한 솔루션은 특수 Spring Data 모듈과 달리 NoSQL 관련 기능이 부족합니다. 또한 관계형 가정이 있는 JPA는 NoSQL 데이터 저장소에 적용될 때 애플리케이션 설계를 잘못된 방향으로 이끌 수 있습니다.

MongoDB를 사용하는 코드는 Spring Data JDBC 예제와 거의 동일할 것입니다. MongoDB 저장소를 사용하려면 다음 종속성을 추가해야 합니다.
```gradle
compile('org.springframework.boot:spring-boot-starter-data-mongodb')
```

온라인 책 카탈로그를 구현해야 한다고 가정해 봅시다. 솔루션은 MongoDB와 Spring Framework를 기반으로 해야 합니다. 
이를 위해 다음 Java 클래스를 사용하여 Book 엔터티를 정의할 수 있습니다.
```java
@Document(collection = "book")                                       // (1)
public class Book {
   @Id                                                               // (2)
   private ObjectId id;                                              // (3)

   @Indexed                                                          // (4)
   private String title;

   @Indexed
   private List<String> authors;                                     // (5)

   @Field("pubYear")                                                 // (6)
   private int publishingYear;

   // constructors, getters and setters
   // ...
}
```
(1) 여기서는 JPA `@Entity` 대신 `@Document` 주석을 사용합니다. 이 주석은 MongoDB에만 해당되며 올바른 데이터베이스 컬렉션을 참조할 수 있도록 합니다. 

(2) 또한 엔티티의 내부 ID를 정의하기 위해 Spring Data 주석 `@Id`와 함께 MongoDB 특정 유형인 `@ObjectId`를 사용합니다. 우리 엔터티와 결과적으로 데이터베이스 문서에는 제목 필드가 포함되며 이 필드는 MongoDB에서도 인덱싱됩니다. 

(4) 이를 위해 @Indexed 주석으로 필드를 장식합니다. 이 주석은 인덱싱 세부 정보와 관련된 몇 가지 구성 옵션을 제공합니다. 

(5) 또한 책에는 한 명 이상의 저자가 있을 수 있으며 저자 필드의 유형을 `List<String>`으로 선언하여 이를 나타냅니다. 작성자 필드도 인덱싱됩니다. 여기서 우리는 다대다 관계가 있는 별도의 작성자 테이블에 대한 참조를 생성하지 않습니다. 이는 관계형 데이터베이스로 구현될 가능성이 높기 때문입니다. 대신 저자 이름을 하위 문서로 book 엔터티에 포함합니다. 

(6) 마지막으로 publicationYear 필드를 정의합니다. 엔터티와 데이터베이스의 필드 이름이 다릅니다. `@Field` 주석은 이러한 경우에 대한 사용자 정의 매핑을 허용합니다

데이터베이스에서 이러한 책 엔터티는 다음 JSON 문서로 표시됩니다.
```json
{
    "_id" : ObjectId("5b1c0908eb696eddfadc0b1b"),                  /*(1)*/
    "title" : "The Expanse: Leviathan Wakes",
    "pubYear" : 2011,                                              /*(2)*/
    "authors" : [                                                  /*(3)*/
        "Daniel Abraham",                                          /*   */
        "Ty Franck"                                                /*   */
    ],
    "_class" : "org.rpis5.chapters.chapter_07.mongo_repo.Book"     /*(4)*/
}
```
(1) MongoDB는 특별히 설계된 데이터 유형을 사용하여 문서의 ID를 나타냅니다. 

(2) 이 경우, publicationYear는 pubYear 필드에 매핑되고 작성자는 배열(3)로 표시됩니다. 

또한 Spring Data MongoDB는 Object-Document Mapping에 사용되는 Java 클래스를 설명하는 지원 _class 필드를 추가합니다.

MongoDB를 사용하면 저장소 인터페이스가 `org.springframework.data.mongodb.repository.MongoRepository` 인터페이스(1)를 확장해야 하며, 이는 이전 예제에서 이미 사용한 CrudRepository를 차례로 확장합니다.

```java
@Repository
public interface BookSpringDataMongoRepository
   extends MongoRepository<Book, Integer> {                          // (1)

   Iterable<Book> findByAuthorsOrderByPublishingYearDesc(            // (2)
       String... authors
   );

   @Query("{ 'authors.1': { $exists: true } }")                      // (3)
   Iterable<Book> booksWithFewAuthors();
}
```

물론 MongoDB 리포지토리는 명명 규칙에 따라 쿼리 생성을 지원하므로 `findByAuthorsOrderByPublishingYearDesc` 메서드는 저자별로 책을 검색하고 가장 최근 출판물부터 시작하여 출판 연도별로 정렬된 결과를 반환합니다. 또한 `org.springframework.data.mongodb.repository.Query` 주석을 사용하면 MongoDB 관련 쿼리를 작성할 수 있습니다. 예를 들어 앞의 쿼리 (3)은 저자가 두 명 이상인 책을 교묘하게 검색합니다.

나머지 애플리케이션은 Spring Data JDBC 또는 Spring Data JPA의 경우와 동일한 방식으로 작동해야 합니다.

Spring을 사용하여 데이터 지속성을 위한 주요 접근 방식을 다루었지만 이 영역의 표면을 거의 긁지 않았습니다. 엔터티 매핑, 캐싱 및 성능 조정의 모범 사례인 트랜잭션 관리, 데이터베이스 초기화 및 마이그레이션(Liquibase, Flyway)을 완전히 생략했습니다. 이 모든 영역은 한 권 이상의 책을 채울 수 있지만 우리는 앞으로 나아가서 반응형으로 지속성을 수행하는 방법을 조사해야 합니다.

Spring Framework를 사용하여 NoSQL 데이터베이스에 대한 반응 지원을 달성하려면 전체 기반 인프라가 반응형 또는 비동기 API를 제공해야 합니다. 일반적으로 NoSQL 데이터베이스는 비교적 최근에 등장했고 빠르게 진화했기 때문에 많은 인프라가 동기식 차단 API에 크게 제한되지 않습니다. 결과적으로, JDBC 드라이버가 있는 관계형 데이터베이스보다 NoSQL 데이터베이스를 사용하여 반응형 지속성을 달성하는 것이 더 쉬워야 합니다. 지금까지 Spring Data에는 몇 가지 반응형 데이터 커넥터가 있으며 MongoDB가 그 중 하나입니다. 이것은 Spring 데이터를 사용한 반응형 데이터 액세스 섹션의 뒷부분에서 다룹니다.


## 동기식 모델의 한계

Spring Framework 또는 일반적으로 Java를 사용하여 지속성 옵션을 조사하는 동안 JDBC, JPA, Hibernate, EclipseLink, Spring Data JDBC 및 Spring Data JDBC를 살펴보았고 이러한 모든 API 및 라이브러리는 본질적으로 동기 및 차단입니다. 네트워크 호출과 관련된 외부 서비스에서 데이터 검색에 거의 항상 사용되지만 비차단 상호 작용을 허용하지 않습니다. 결과적으로 앞서 언급한 모든 API 및 라이브러리는 반응형 패러다임과 충돌합니다. 데이터베이스에 대한 쿼리를 실행하는 Java 스레드는 첫 번째 데이터 조각이 도착하거나 타임아웃이 발생할 때까지 차단될 운명이며, 이는 반응형 애플리케이션의 리소스 관리 관점에서 보면 꽤 낭비입니다. "6장, WebFlux 비동기식 비차단 통신"에서 설명한 대로 이 접근 방식은 애플리케이션의 처리량을 크게 제한하고 더 많은 서버 리소스를 필요로 하므로 더 많은 비용이 필요합니다.

HTTP 요청이든 데이터베이스 요청이든 차단 방식으로 IO 요청을 하는 것은 낭비입니다. 또한 JDBC 기반 통신은 일반적으로 전체 연결 풀을 사용하여 쿼리를 병렬로 실행합니다. 대조적으로 널리 사용되는 HTTP2 프로토콜은 동일한 TCP 연결을 사용하여 동시에 여러 리소스를 보내고 받을 수 있습니다. 이 접근 방식은 점유된 TCP 소켓의 수를 줄이고 클라이언트와 서버(이 경우 데이터베이스) 모두에 대해 더 큰 동시성을 허용합니다. 다음 다이어그램을 고려하십시오.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781787284951/files/assets/2c336d00-2983-49e0-9ba0-9829d34d80b7.png)

그림 7.15 일반적인 데이터베이스 통신과 HTTP2와 같이 다중화를 허용하는 통신 프로토콜 간의 비교

물론 연결 풀은 새 연결을 열 때 시간을 절약하기 위해 존재합니다. HTTP2와 같이 다중화를 활용하기 위해 JDBC 아래에 통신 계층을 구현하는 것도 가능하지만 여전히 JDBC 수준 이전의 코드는 동기 및 차단이어야 합니다.

마찬가지로 몇 개의 배치를 차지하는 대용량 쿼리 결과를 처리할 때 데이터베이스 커서(쿼리 결과 레코드를 반복할 수 있는 제어 구조)와의 통신은 앞의 다이어그램의 왼쪽과 같습니다. "3장, Reactive Streams - 새로운 Streams의 표준"에서는 Reactive Streams의 관점에서 통신 옵션 간의 차이점을 자세히 분석하지만 동일한 주장이 네트워크 상호 작용에 적용됩니다.

데이터베이스가 효율적으로 통신할 수 있고 연결 멀티플렉싱을 활용할 수 있는 비동기식 비차단 드라이버를 제공하더라도 JDBC, JPA 또는 Spring Data JPA를 사용할 때 잠재력을 충분히 얻을 수 없습니다. 결과적으로 완전히 반응형 애플리케이션을 구축하려면 동기 기술을 포기하고 반응형 유형을 사용하여 API를 만들어야 합니다.

이 섹션을 요약하면 기존의 잘 정립된 JDBC 및 JPA 구현이 최신 반응형 애플리케이션에서 병목 현상이 될 수 있습니다. JDBC 및 JPA는 런타임에 너무 많은 스레드와 너무 많은 메모리를 사용할 가능성이 가장 높으며 동시에 긴 동기 요청 및 차단 IO를 제한하기 위해 적극적인 캐싱이 필요합니다.

나쁜 것은 동기식 모델이 아닙니다. 반응형 응용 프로그램에 잘 맞지 않고 제한 요소가 될 가능성이 큽니다. 그러나 이러한 모델은 성공적으로 공존할 수 있습니다. 동기식 접근 방식과 사후 접근 방식 모두 장단점이 있습니다. 예를 들어, 지금까지의 반응형 지속성 접근 방식은 기능면에서 JPA에 가까운 ORM 솔루션을 제안할 수 없습니다.

### 동기식 모델의 장점

동기식 데이터 액세스가 지속성 계층을 구현할 때 서버 리소스를 소비하는 가장 효율적인 방법은 아니지만 주로 차단 웹 응용 프로그램을 빌드하는 데 사용할 때 여전히 매우 가치 있는 접근 방식입니다. JDBC는 데이터 액세스를 위한 가장 널리 사용되는 다목적 API이지만 애플리케이션과 데이터베이스 간의 클라이언트-서버 통신 복잡성을 거의 완전히 숨깁니다. Spring Data JDBC 및 Spring Data JPA는 데이터 지속성을 위한 더 높은 수준의 도구를 제공하여 쿼리 변환 및 트랜잭션 관리의 엄청난 복잡성을 숨깁니다. 이 모든 것은 전투 테스트를 거쳤으며 최신 응용 프로그램이 개발되는 방식을 상당히 단순화합니다.

동기식 데이터 액세스는 간단하고 디버그하기 쉽고 테스트하기 쉽습니다. 또한 스레드 풀을 모니터링하여 리소스 사용량을 쉽게 추적할 수 있습니다. 동기식 접근 방식은 역압 지원이 필요하지 않지만 반복자와 동기식 스트림을 사용할 때 여전히 효율적일 수 있는 방대한 도구 세트(예: JPA 및 Spring Data 커넥터)를 제공합니다. 또한 대부분의 최신 데이터베이스는 내부적으로 차단 모델을 사용하므로 상호 작용에 차단 드라이버를 사용하는 것이 당연합니다. 이 동기식 접근 방식은 로컬 및 분산 트랜잭션을 훌륭하게 지원합니다. 또한 C 또는 C++로 작성된 기본 드라이버를 통해 래퍼를 구현하는 것도 쉽습니다.

동기식 데이터 액세스의 유일한 단점은 실행 차단 방식에 있으며 이는 반응형 패러다임(Netty, Reactor, WebFlux)으로 구축된 반응형 웹 애플리케이션과 호환되지 않습니다.

동기식 데이터 액세스 기술을 간략히 요약한 후 반응형 데이터 지속성 탐색으로 이동하여 Spring Data의 반응형 커넥터가 Spring Data 저장소의 다양성을 손상시키지 않으면서 고성능을 약속하는 방법을 확인할 수 있습니다.



## Spring Data를 이용한 반응형 데이터 접근

따라서 완전히 반응적인 애플리케이션을 구축하려면 엔터티 컬렉션으로 작동하는 저장소가 아니라 엔터티의 반응형 스트림으로 작동하는 저장소가 필요합니다. 반응형 저장소는 엔터티 자체뿐만 아니라 반응형 `Publisher<Entity>`를 사용하여 엔터티를 저장, 업데이트 또는 삭제할 수 있어야 합니다. 또한 반응형을 통해 데이터를 반환해야 합니다. 이상적으로는 데이터베이스를 쿼리할 때 Spring WebFlux 모듈의 WebClient와 유사한 방식으로 데이터 저장소를 사용하고 싶습니다. 실제로 Spring Data Commons 모듈은 그러한 계약과 함께 ReactiveCrudRepository 인터페이스를 제공합니다.

이제 일반적인 차단 계층 대신 반응형 데이터 액세스 계층을 사용할 때 기대할 수 있는 이점에 대해 논의해 보겠습니다. "3장, Reactive Streams - New Streams' Standard"에서는 데이터 검색의 동기식 및 반응형 모델을 비교하므로 이상적인 반응 데이터 액세스 계층을 사용함으로써 우리 애플리케이션은 다음과 같은 모든 이점을 얻을 수 있습니다.

- **IO 작업을 차단하는 데 스레드가 필요하지 않으므로 효과적인 스레드 관리** 이것은 일반적으로 더 적은 수의 스레드가 생성되고, 스레드 스케줄링에 대한 오버헤드가 적으며, Thread 개체의 스택에 할당된 메모리 공간이 적기 때문에 결과적으로 엄청난 양의 동시 연결을 처리할 수 있음을 의미합니다.

- **쿼리의 첫 번째 결과에 대한 지연 시간이 더 짧습니다.** 쿼리가 완료되기 전에도 사용할 수 있게 될 수 있습니다. 짧은 대기 시간 작업을 목표로 하는 검색 엔진 및 대화형 UI 구성 요소에 편리할 수 있습니다.

- **더 낮은 메모리 풋프린트**. 이것은 나가는 트래픽이나 들어오는 트래픽에 대한 쿼리를 처리할 때 버퍼링해야 하는 데이터가 더 적기 때문에 유용합니다. 또한 클라이언트는 요구 사항을 충족하기에 충분한 데이터가 있는 즉시 반응 스트림에서 구독을 취소하고 네트워크를 통해 전송되는 데이터의 양을 줄일 수 있습니다.

- **역압 전파**는 클라이언트에게 데이터베이스가 새로운 데이터를 소비할 수 있는 능력을 알려줍니다. 또한 쿼리 결과를 처리하는 클라이언트의 능력에 대해 데이터베이스 서버에 알릴 수 있습니다. 이 경우 더 긴급한 작업이 대신 수행될 수 있습니다.

- 반응형 클라이언트가 스레드 바인딩되지 않는다는 사실에서 또 하나의 이점이 있을 수 있으므로 쿼리를 보내고 다른 데이터 처리 작업이 다른 스레드에서 발생할 수 있습니다. 결과적으로 기본 쿼리 및 연결 개체는 이러한 작동 모드를 허용해야 합니다. 어떤 스레드도 쿼리 개체에 대한 배타적 권한을 보유하지 않고 클라이언트 코드가 차단되지 않으므로 **데이터베이스에 대한 단선 연결을 공유**하고 연결 풀링을 잊어버릴 수 있습니다. 데이터베이스가 스마트 연결 모드를 지원하는 경우 쿼리 결과는 단일 물리적 네트워크 연결을 통해 전송되고 올바른 반응 가입자에게 라우팅될 수 있습니다.

- 마지막으로, 리액티브 애플리케이션의 유창한 리액티브 코드와 퍼시스턴스 레이어의 원활한 통합은 리액티브 스트림 사양에 의해 뒷받침됩니다.

데이터베이스 액세스 스택이 반응성이 높을수록 애플리케이션이 더 많은 이점을 가질 수 있습니다. 그러나 비동기 드라이버 또는 적절한 반응형 어댑터에 래핑된 차단 드라이버를 적용하여 앞서 언급한 이점 중 일부를 얻을 수 있습니다. 응용 프로그램은 역압을 전파하는 기능을 잃을 수 있지만 여전히 더 적은 메모리를 사용하고 적절한 스레드 관리를 가질 수 있습니다. 이제 Spring Boot 애플리케이션에서 반응형 코드로 플레이할 시간입니다.

Spring Boot 애플리케이션에서 반응형 지속성을 활성화하려면 반응형 커넥터가 있는 데이터베이스 중 하나를 사용해야 합니다. 작성 당시 Spring Data 프로젝트는 MongoDB, Cassandra, Redis 및 Couchbase에 대한 반응형 연결을 제공합니다. 이 목록은 제한적일 수 있지만 현재로서는 반응형 지속성이 여전히 널리 받아들여지는 참신함입니다. 또한 Spring 팀이 더 많은 데이터베이스를 반응적으로 지원하는 것을 제한하는 주요 제약 요소는 데이터베이스에 대한 반응형 및 비동기 드라이버의 부족입니다. 이제 MongoDB의 예에서 반응형 CRUD 저장소가 어떻게 작동하는지 조사해 보겠습니다.

## Using MongoDB reactive repository

동기 대응 대신 MongoDB에 대한 반응 데이터 액세스를 사용하려면 Gradle 프로젝트에 다음 종속성을 추가해야 합니다.
```gradle
compile 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'
```
이전 섹션의 간단한 MongoDB 애플리케이션을 반응형으로 리팩토링하려고 한다고 가정해 보겠습니다. 이 경우 Book 엔터티를 수정하지 않고 그대로 둘 수 있습니다. MongoDB 객체-문서 매핑과 관련된 모든 주석은 동기식과 반응형 MongoDB 모듈 모두 동일합니다. 그러나 저장소에서 이제 일반 유형을 반응 유형으로 바꿔야 합니다.

```java
public interface ReactiveSpringDataMongoBookRepository
   extends ReactiveMongoRepository<Book, Integer> {                  // (1)

   @Meta(maxScanDocuments = 3)                                       // (2)
   Flux<Book> findByAuthorsOrderByPublishingYearDesc(                // (3)
       Flux<String> authors
   );

   @Query("{ 'authors.1': { $exists: true } }")                      // (4)
   Flux<Book> booksWithFewAuthors();
}
```
(1) 따라서 저장소는 이제 `MongoRepository` 대신 `ReactiveMongoRepository` 인터페이스(1)를 확장합니다. 차례로 `ReactiveMongoRepository는` 모든 반응 커넥터에 대한 공통 인터페이스인 `ReactiveCrudRepository` 인터페이스를 확장합니다.

(2) RxJava2MongoRepository가 없지만 `RxJava2CrudRepository`에서 확장하여 RxJava2와 함께 모든 반응 스프링 데이터 저장소를 계속 사용할 수 있습니다. Spring Data는 네이티브 RxJava 2 경험을 제공하기 위해 RxJava2에 대한 프로젝트 리액터 유형의 채택 또는 그 반대의 채택을 처리합니다.

(3) `ReactiveCrudRepository` 인터페이스는 Spring Data의 `CrudRepository` 인터페이스와 동일한 반응형입니다. Reactive Spring Data Repositories는 동일한 주석을 사용하고 동기적으로 제공되는 대부분의 기능을 지원합니다. 따라서 반응형 Mongo 리포지토리는 메서드 이름 규칙(3), 손으로 작성한 MongoDB 쿼리가 있는 @Query 주석(4), 일부 추가 쿼리 조정 기능이 있는 @Meta 주석(2)에 따른 쿼리를 지원합니다. 또한 QBE(Query by Example) 요청을 실행하기 위한 구성을 지원합니다. 

그러나 동기식 MongoRepository와 달리 `ReactiveMongoRepository`는 특정 결과 순서를 요청할 수 있는 기능을 제공하지만 페이지 매김 지원은 제공하지 않는 `ReactiveSortingRepository` 인터페이스를 확장합니다. 데이터 페이지 매김에 대한 질문은 페이지 매김 지원 섹션에서 다룹니다.

평소와 같이 애플리케이션에 `ReactiveSpringDataMongoBookRepository` 유형의 빈을 주입하면 Spring Data가 원하는 빈을 제공할 것입니다. 다음 코드는 반응형 저장소를 사용하여 몇 권의 책을 MongoDB에 삽입하는 방법을 보여줍니다.
```java
@Autowired
private ReactiveSpringDataMongoBookRepository rxBookRepository;      // (1)
...
Flux<Book> books = Flux.just(                                        // (2)
   new Book("The Martian", 2011, "Andy Weir"),
   new Book("Blue Mars", 1996, "Kim Stanley Robinson")
);

rxBookRepository
   .saveAll(books)                                                   // (3)
   .then()                                                           // (4)
   .doOnSuccess(ignore -> log.info("Books saved in DB"))             // (5)
   .subscribe();                                                     // (6)
```
앞의 코드가 여기서 무엇을 하는지 이해합시다.

(1) `BookSpringDataMongoRxRepository` 인터페이스로 빈 주입.

(2) 데이터베이스에 삽입해야 하는 Book으로 반응 스트림을 준비합니다.

(3) `Publisher<Book>`을 사용하는 `saveAll` 메서드를 사용하여 엔터티를 저장합니다. 평소와 같이 실제 구독자가 구독할 때까지 저장이 발생하지 않습니다. `ReactiveCrudRepository`에는 Iterable 인터페이스를 사용하는 saveAll 메서드 재정의도 있습니다. 이 두 가지 방법은 의미 체계가 다르지만 이 주제는 나중에 다룰 것입니다.

(4) saveAll 메소드는 저장된 엔티티와 함께 ​​Flux<Book>을 리턴하지만, 우리는 그 세부 수준에 관심이 없기 때문에 then 메소드를 사용하여 onComplete 또는 onError 이벤트만 전파되는 방식으로 스트림을 변환합니다.

(5) 반응 스트림이 완료되고 모든 책이 저장되면 해당 로그 메시지를 보고합니다.

(6) 항상 그렇듯이 반응 스트림에는 구독자가 있어야 합니다. 여기서는 단순함을 위해 핸들러 없이 구독합니다. 그러나 실제 응용 프로그램에는 응답을 처리하는 WebFlux 교환의 구독과 같은 실제 구독자가 있어야 합니다.

이제 Reactive Streams를 사용하여 MongoDB를 쿼리해 보겠습니다. 반응형 스트림을 통해 흐르는 쿼리 결과를 인쇄하려면 다음과 같은 편리한 도우미 메서드를 사용할 수 있습니다.

```java
private void reportResults(String message, Flux<Book> books) {     // (1)
   books
      .map(Book::toString) // (2)
      .reduce( // (3)
         new StringBuilder(), // (3.1)
         (sb, b) -> sb.append(" - ") // (3.2)
            .append(b)
            .append("\n"))
      .doOnNext(sb -> log.info(message + "\n{}", sb)) // (5)
      .subscribe(); // (6)
}
```
앞의 코드가 여기서 무엇을 하는지 이해합시다.

(2) 이것은 사람이 읽을 수 있는 책 목록을 원하는 메시지 접두사가 있는 하나의 로그 메시지로 인쇄하는 방법입니다.
스트림의 각 책에 대해 toString 메서드를 호출하고 문자열 표현을 전파합니다.

(3) Flux.reduce 메소드는 모든 책 표현을 하나의 메시지로 수집하는 데 사용됩니다. 책의 양이 많은 경우 이 접근 방식이 작동하지 않을 수 있습니다. 새 책이 나올 때마다 저장된 버퍼의 크기가 증가하고 메모리 소비가 많이 발생할 수 있기 때문입니다. 

(3.1) 중간 결과를 저장하기 위해 StringBuilder 클래스(3.1)를 사용합니다. StringBuilder는 스레드로부터 안전하지 않으며 onNext 메서드는 다른 스레드를 호출할 수 있지만 Reactive Streams 사양은 발생 이전 관계를 보장합니다. 따라서 다른 스레드가 다른 엔터티를 푸시하더라도 메모리 장벽이 하나의 반응 스트림 내에서 업데이트되는 동안 StringBuilder 개체의 최신 상태를 보장하므로 StringBuilder와 함께 연결하는 작업을 하는 것이 안전합니다. 

(3.2)에서 책 표현이 단일 버퍼에 추가됩니다. reduce 메소드는 들어오는 모든 onNext 이벤트를 처리한 후에만 onNext 이벤트를 방출하므로 모든 책에 최종 메시지를 기록하는 것이 안전합니다.

(6) 처리를 시작하려면 구독해야 합니다. 단순함을 위해 여기서는 오류가 발생하지 않는다고 가정합니다. 그러나 프로덕션 코드에는 오류 처리를 위한 몇 가지 논리가 있어야 합니다.

이제 데이터베이스의 모든 책을 읽고 보고해 보겠습니다.
```java
Flux<Book> allBooks = rxBookRepository.findAll();
reportResults("All books in DB:", allBooks);
```
The following code searches for all books by Andy Weir using the method naming convention:
```java
Flux<Book> andyWeirBooks = rxBookRepository
   .findByAuthorsOrderByPublishingYearDesc(Mono.just("Andy Weir"));
reportResults("All books by Andy Weir:", andyWeirBooks);
```

또한 앞의 코드는 `Mono<String>` 유형을 사용하여 검색 기준을 전달하고 해당 Mono가 onNext 이벤트를 생성할 때만 실제 데이터베이스 쿼리를 시작합니다. 따라서 반응 저장소는 들어오는 스트림과 나가는 스트림이 반응하는 반응 스트림의 자연스러운 부분이 됩니다.